---
layout: post
title: LeetCode-链表
excerpt: "LeetCode问题的解答：链表"
categories: [Algorithm]
comments: true


---

##  617. Merge Two Binary Trees 

> Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
>
> You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.
>
> **Example 1:**
>
> ```
> Input: 
> 	Tree 1                     Tree 2                  
>           1                         2                             
>          / \                       / \                            
>         3   2                     1   3                        
>        /                           \   \                      
>       5                             4   7                  
> Output: 
> Merged tree:
> 	     3
> 	    / \
> 	   4   5
> 	  / \   \ 
> 	 5   4   7
> ```

这道题可以递归地同时访问`t1`和`t2`。在它们的当前根节点都不为None时，新建一个节点，其值为两个根节点值的和；在某个根节点为None时，新建一个树，其为另一个根节点所属子树的拷贝（在我的代码中，我没有做这一步，因为偷懒了，而且时间会更快……但这是不对的）；如果两个根节点都是None，则返回None。

```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1 and not t2:
            return None
        elif not t1:
            return t2
        elif not t2:
            return t1
        else:
            node = TreeNode(t1.val + t2.val)
            node.left = self.mergeTrees(t1.left, t2.left)
            node.right = self.mergeTrees(t1.right, t2.right)
            return node
```



##  338. Counting Bits 

> Given a non negative integer number **num**. For every numbers **i** in the range **0 ≤ i ≤ num** calculate the number of 1's in their binary representation and return them as an array.
>
> **Example 1:**
>
> ```
> Input: 2
> Output: [0,1,1]
> ```
>
> **Example 2:**
>
> ```
> Input: 5
> Output: [0,1,1,2,1,2]
> ```

**(1)** DP方法：

一个数如果是奇数，那么它的二进制表示会比它右移一位的数的二进制表示多一个一；否则一的个数相等。

```python
class Solution:
    def countBits(self, num: int):
        dp = [0 for _ in range(num+1)]
        for i in range(1, num+1):
            if i % 2 == 0:
                dp[i] = dp[i//2]
            else:
                dp[i] = dp[i//2] + 1
        return dp
```

**(2)** 找规律：

`[2^n, 2^(n+1))`的数字数目，等于`[0:2^n)`的数字数目（因为在`[0:2^n)`的每个数的二进制表示前面加一个1，就会变成`[2^n, 2^(n+1))`里的数）。因此，可以先求去一个最小的`n`，使得`2^n>num`，然后每次使用`[0:2^i)`中的数的1的个数，去求`[2^i, 2^(i+1))`中的数的1的个数（只需加一即可），并将结果添加至结果数组里。最后，取结果数组的前`num+1`项。

```python
class Solution:
    def countBits(self, num: int):
        if num == 0:
            return [0]
        # find a n which is the smallest integer that 2^n >= num
        n, tmp = -1, num
        while tmp != 0:
            n += 1
            tmp >>= 1
        ans = [0, 1]
        # construct ans[:2^n]
        while n > 0:
            ans.extend([1+x for x in ans])
            n -= 1
        return ans[:num+1]
```



##  104. Maximum Depth of Binary Tree 

> Given a binary tree, find its maximum depth.
>
> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
>
> **Note:** A leaf is a node with no children.
>
> **Example:**
>
> Given binary tree `[3,9,20,null,null,15,7]`,
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
>
> return its depth = 3.

非常基础的递归。

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

这是DFS，或者也可以用层次遍历/BFS。因为所有节点都必须被访问一次，所以没有时间上的区别。



## 136. Single Number

```python
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,1]
Output: 1
Example 2:

Input: [4,1,2,1,2]
Output: 4
```

把全部数XOR起来，剩下的数就是the single one。这是因为相同的数异或为0，而0与其他数异或为其他数。

```python
from functools import reduce

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x^y, nums)
```



## 406. Queue Reconstruction by Height

> Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers `(h, k)`, where `h` is the height of the person and `k` is the number of people in front of this person who have a height greater than or equal to `h`. Write an algorithm to reconstruct the queue.
>
> **Note:**
> The number of people is less than 1,100.
>
> **Example**
>
> ```
> Input:
> [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
> 
> Output:
> [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
> ```

一个比较矮的人无论是站在一个更高的人的前面或者后面，对他的`k`值都不会有影响。因此，可以考虑用插入的方式构造队列：先插入最高的人，然后插入第二高的，然后是第三高……直到插入了所有人。插入一个比较矮的人，对队列中已经存在的人的`k`是没有影响的。因此，只需要为这个比较矮的人寻找一个合适的位置，让他取到对的`k`值，就能让队列中已有的人的`k`值都是正确的。就像这样，不断插入拥有对的`k`值的人，最终排好的队列中的人的`k`值都会是对的。

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        ans = []
        for each in people:
            ans.insert(each[1], each)
        return ans
```

```c++
class Solution {
   public:
    vector<vector<int>> reconstructQueue(vector<vector<int>> &people) {
        if (people.size() == 0) return {};
        std::sort(
            people.begin(), people.end(), [](vector<int> &x, vector<int> &y) {
                return x[0] > y[0] || (x[0] == y[0] && x[1] < y[1]);
            });
        vector<vector<int>> rtn;
        for (auto &p : people) {
            rtn.insert(rtn.begin() + p[1], p);
        }
        return rtn;
    }
};
```




## 739. Daily Temperatures

> Given a list of daily temperatures `T`, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead.
>
> For example, given the list of temperatures `T = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`.
>
> **Note:** The length of `temperatures` will be in the range `[1, 30000]`. Each temperature will be an integer in the range `[30, 100]`.

这种求一个方向上的递增或递减的题，大部分可以用栈解决。使用一个栈`stack`，用来在访问完每个温度值后存入该温度值的索引。在访问一个新的温度值`t`时，如果它跟栈顶温度值索引对应的温度相比更大时，便进行`pop`，并在栈顶索引对应的输入数组位置上记录数值。简单地说，`stack`里留存的是那些还没有找到接下来的更暖气温的气温值索引。在它们找到了一个更暖的气温后，便从栈中弹出，并记录花费的天数。

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        stack = []
        ans = [0 for _ in range(len(T))]
        for i, t in enumerate(T):
            while stack and T[stack[-1]] < t:
                ans[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return ans
```




## 226. Invert Binary Tree

> Invert a binary tree.
>
> **Example:**
>
> Input:
>
> ```
>      4
>    /   \
>   2     7
>  / \   / \
> 1   3 6   9
> ```
>
> Output:
>
> ```
>      4
>    /   \
>   7     2
>  / \   / \
> 9   6 3   1
> ```

传说中Homebrew作者面试谷歌时做不出而导致被挂的题……其实很简单嘛，可能是一时忘了二叉树的结构？……感觉这道题在递归之中确实是偏简单，把当前访问节点的左右节点互换，然后递归地处理左右子树就行了。

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```




## 94. Binary Tree Inorder Traversal

> Given a binary tree, return the *inorder* traversal of its nodes' values.
>
> **Example:**
>
> ```
> Input: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
> 
> Output: [1,3,2]
> ```

参见[另一个页面](https://two2er.github.io/pages/algorithms/2019-10-08-unusual-algorithms)。




## 46. Permutations

> Given a collection of **distinct** integers, return all possible permutations.
>
> **Example:**
>
> ```
> Input: [1,2,3]
> Output:
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]
> ```

这道题最符合直觉的做法就是递归。假设通过递归，获得了`nums[1:]`的所有置换后，要获得`nums`的置换，只需要将`nums[0]`插入到`nums[1:]`的置换的各个位置上即可。或者也可以换种思路：依次取`nums`中的一个元素`nums[i]`，计算剩下元素`nums[:i]+nums[i+1:]`的所有置换。然后在这些置换的最前添加`nums[i]`（也就是计算所有以`nums[i]`开头的置换）。这两种方法简单地想，应该有差不多的复杂度（不过在LeetCode的测试用例上第一种会省时一点。但是算法复杂度应该是一样的）

```PYTHON
class Solution:
    def permute(self, nums: 'List[int]') -> 'List[List[int]]':
        if len(nums) <= 1:
            return [nums]
        pers = self.permute(nums[1:])
        ans = []
        for each in pers:
            for i in range(len(each)+1):
                ans.append(each[:i] + [nums[0]] + each[i:])
        return ans
```

```python
class Solution:
    def permute(self, nums: 'List[int]') -> 'List[List[int]]':
        if len(nums) <= 1:
            return [nums]
        ans = []
        for i in range(len(nums)):
            pers = self.permute(nums[:i] + nums[i+1:])
            ans.extend([[nums[i]] + each for each in pers])
        return ans
```

下面是[Permutations II](https://leetcode.com/problems/permutations-ii/)，`nums`中会有重复，结果需要去重。做法的思路是一样的，只是需要先对`nums`进行排序，在碰到重复元素时跳过即可。

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        if len(nums) <= 1:
            return [nums]
        ans = []
        nums.sort()
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            pers = self.permuteUnique(nums[:i] + nums[i+1:])
            ans.extend([[nums[i]] + each for each in pers])
        return ans
```



## 647. Palindromic Substrings

> Given a string, your task is to count how many palindromic substrings in this string.
>
> The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
>
> **Example 1:**
>
> ```
> Input: "abc"
> Output: 3
> Explanation: Three palindromic strings: "a", "b", "c".
> ```
>
>  
>
> **Example 2:**
>
> ```
> Input: "aaa"
> Output: 6
> Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
> ```

这道题我已知的有两种做法。第一种是我用的DP方法。令`dp[i][j]`表示子串`s[i:j+1]`是否为回文。对于所有`i`，肯定有`dp[i][i] = 1`。然后依次计算`s`的长度为`length`的子串是否回文。如果`s[i+1:i+length-1]`是回文，且`s[i] == s[i+length]`，那么`s[i:i+length+1]`也会是回文。这种做法的时间复杂度是`O(n^2)`。不过这种方法不如下面一种[方法](https://leetcode.com/problems/palindromic-substrings/discuss/105689/Java-solution-8-lines-extendPalindrome)。下面的方法在`s[i:j]`不为回文的情况下，就不会再计算`s[i-1:j+1]`、`s[i-2:j+2]`……了，在效率上更佳。

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        if not s:
            return 0
        # dp[i][j] = num of palindromic substrings in s[i:j+1]
        dp = [[0 for _ in s] for _ in s]
        for i in range(len(s)):
            dp[i][i] = 1
        for length in range(1, len(s)):
            for i in range(len(s)):
                end = i + length
                if end >= len(s):
                    continue
                if s[i] == s[end] and (length == 1 or dp[i+1][end-1]):
                    dp[i][end] = 1
        return sum([sum(each) for each in dp])
```

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        if not s:
            return 0

        self.count = 0
        def extend(left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                self.count += 1
                left, right = left - 1, right + 1
                
        for i in range(len(s)):
            extend(i, i)
            extend(i, i + 1)
        return self.count
```



## 22. Generate Parentheses

> Given *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
>
> For example, given *n* = 3, a solution set is:
>
> ```
> [
>   "((()))",
>   "(()())",
>   "(())()",
>   "()(())",
>   "()()()"
> ]
> ```

这是一个非常简单的回溯问题。在回溯过程中，保持以下规律：

- 每添加一个"("，就必须添加一个")"
- "("的总数为`n`
- “)"的个数在子串`s[:i]`中不能比"("的个数多

就可以筛选掉那些不符合要求的置换。

```python
class Solution:
    def generateParenthesis(self, n: int) -> 'List[str]':
        if n == 0:
            return []
        ans = []

        def recursive(left, right, s):
            if left == 0 and right == 0:
                ans.append(s)
            if left > 0:
                recursive(left - 1, right + 1, s + '(')
            if right > 0:
                recursive(left, right - 1, s + ')')

        recursive(n, 0, '')
        return ans
```



## 206. Reverse Linked List

>Reverse a singly linked list.
>
>**Example:**
>
>```
>Input: 1->2->3->4->5->NULL
>Output: 5->4->3->2->1->NULL
>```

这道题非常经典……见了无数次。首先是递归版本。递归地将当前头部的下个节点为头部的链表翻转。然后翻转链表的尾部——即当前头部的下一个节点——的`next`设为头部，而头部的`next`设为`None`即可。另外，递归还可以像[这样](https://leetcode.com/problems/reverse-linked-list/discuss/58125/In-place-iterative-and-recursive-Java-solution)，在递归过程中按顺序翻转节点间的指向（从头到尾，而我的是从尾到头）。

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head
```

迭代版本使用3个指针`prev`，`cur`和`nex`来分别指向当前节点的前一个节点、当前节点、当前节点下一个节点。在迭代过程中，将`cur.next`设为`prev`，然后三个指针分别向前移动一个节点（`nex`的意义是为了防止改变`cur.next`后无法到达原链表中当前节点的下一个节点）。

```python
class Solution:    
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        prev, cur, nex = None, head, head.next
        while nex:
            cur.next = prev
            prev, cur, nex = cur, nex, nex.next
        cur.next = prev
        return cur
```



## 347. Top K Frequent Elements

> Given a non-empty array of integers, return the **k** most frequent elements.
>
> **Example 1:**
>
> ```
> Input: nums = [1,1,1,2,2,3], k = 2
> Output: [1,2]
> ```
>
> **Example 2:**
>
> ```
> Input: nums = [1], k = 1
> Output: [1]
> ```

如果用Counter来计算频率的话，那代码就太简单了。在排序频率时可以优化。因为所有数的频率的范围在`[1, len(nums)]`之间，所以可以用桶`bucket[i]`来装频率为`i`的所有数。这样算法复杂度可以降到`O(n)`。不过可能是桶使用列表来装数，不如builtin函数高效，用桶的实现甚至比下面的代码还慢。

```python
from collections import Counter

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ctr = Counter(nums)
        return [x[0] for x in sorted(ctr.items(), key=lambda x: -x[1])[:k]]
```



## 238. Product of Array Except Self

> Given an array `nums` of *n* integers where *n* > 1,  return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.
>
> **Example:**
>
> ```
> Input:  [1,2,3,4]
> Output: [24,12,8,6]
> ```

题目的意思是，`ans[i]`是`nums[:i] + nums[i+1:]`中元素的累乘。因此，可以从左到右线性地算出各个`nums[:i]`的累乘，再从右到左算出各个`nums[i+1:]`的累乘。然后，`ans[i]`等于对应位置的左右累乘的积。这样算法复杂度就为`O(n)`。下面的做法用了两个数组记录左右累乘，来回共遍历了3趟。[这个做法](https://leetcode.com/problems/product-of-array-except-self/discuss/65622/Simple-Java-solution-in-O(n)-without-extra-space)把计算从右到左累乘和计算结果两步合在一起了，并且少用一个数组，大有可借鉴之处。

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        left, right = [1 for _ in nums], [1 for _ in nums]
        for i in range(1, len(nums)):
            left[i] = left[i-1] * nums[i-1]
        for i in range(len(nums)-2, -1, -1):
            right[i] = right[i+1] * nums[i+1]
        for i in range(len(nums)):
            left[i] = left[i] * right[i]
        return left
```

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        left, right = [1 for _ in nums], 1
        for i in range(1, len(nums)):
            left[i] = left[i-1] * nums[i-1]
        for i in range(len(nums)-1, -1, -1):
            left[i] = left[i] * right
            right = right * nums[i]
        return left
```



## 78. Subsets

> Given a set of **distinct** integers, `nums`, return all possible subsets (the power set).
>
> **Note:** The solution set must not contain duplicate subsets.
>
> **Example:**
>
> ```
> Input: nums = [1,2,3]
> Output:
> [
>   [3],
>   [1],
>   [2],
>   [1,2,3],
>   [1,3],
>   [2,3],
>   [1,2],
>   []
> ]
> ```

这题是典型的回溯。关于回溯，讨论区有个人总结了一些LeetCode上的[回溯题](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))。我下面的做法比较符合直觉，不过也可以像链接中那样，用循环代替一层递归，这样可能会比较省空间。

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        
        def recursive(arr, i):
            if i >= len(nums):
                ans.append(arr.copy())
            else:
                arr.append(nums[i])
                recursive(arr, i+1)
                arr.pop()
                recursive(arr, i+1)
        
        recursive([], 0)
        return ans
```

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        
        def recursive(arr, i):
            ans.append(arr.copy())
            for j in range(i, len(nums)):
                arr.append(nums[j])
                recursive(arr, j+1)
                arr.pop()
        
        recursive([], 0)
        return ans
```

下面是[Subsets II](https://leetcode.com/problems/subsets-ii/)，`nums`中的元素会重复，要求要去重。思路是一样的，只是回溯时需要跳过重复的元素。

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort()
        
        def recursive(arr, i):
            ans.append(arr.copy())
            for j in range(i, len(nums)):
                if j > i and nums[j] == nums[j-1]:
                    continue
                arr.append(nums[j])
                recursive(arr, j+1)
                arr.pop()
        
        recursive([], 0)
        return ans
```



## 283. Move Zeroes

> Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.
>
> **Example:**
>
> ```
> Input: [0,1,0,3,12]
> Output: [1,3,12,0,0]
> ```

使用一个指针`i`，`nums[:i]`都是非0的数，且保留了原来的顺序。然后遍历`nums`，每发现一个非0的数，就跟`nums[i]`调换，并且让`i`加一。这道题的思路跟`low, high`指针（或者`left, right`指针）操作一个线性数组的题目是一样的。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        i = 0
        for j, num in enumerate(nums):
            if num != 0:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
```



## 169. Majority Element

> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.
>
> You may assume that the array is non-empty and the majority element always exist in the array.
>
> **Example 1:**
>
> ```
> Input: [3,2,3]
> Output: 3
> ```
>
> **Example 2:**
>
> ```
> Input: [2,2,1,1,1,2,2]
> Output: 2
> ```

这道题的解法，是一种叫[Boyer–Moore majority vote algorithm]([https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm#:~:targetText=The%20Boyer%E2%80%93Moore%20majority%20vote,linear%20time%20and%20constant%20space.&targetText=In%20its%20simplest%20form%2C%20the,the%20elements%20of%20the%20input.](https://en.wikipedia.org/wiki/Boyer–Moore_majority_vote_algorithm#:~:targetText=The Boyer–Moore majority vote,linear time and constant space.&targetText=In its simplest form%2C the,the elements of the input.))的算法。附带一个这个算法的[证明](https://www.quora.com/What-is-the-proof-of-correctness-of-Moores-voting-algorithm)。

在起始时，将`nums[0]`当做majority element（me）。`count`的意义是“在已经访问的元素中，当前me的数目比不是me的数目多的个数”。故起始时`count`为1。顺序访问数组，如果访问到的数等于当前me，则`++count`；否则`--count`。

可以用数学归纳法证明。如果`nums.size() == 1`，显然返回的元素（第一个元素）是正确答案。

设`nums.size()`在`[1, n-1]`以内时返回的元素是正确答案。

如果`count == 0`，说明目前已访问的元素中，没有一个的个数比其他的总数大。设已经访问了`x`个元素，则全局me在这`x`个元素中至多出现了`x/2`次。由于me的个数大于`n/2`，所以在剩下的`n-x`个元素中，它至少会出现`(n-x)/2+1`次，即它在剩下的`n-x`个元素中依然是me。那么对剩下的`n-x`个元素递归地调用函数`majorityElement`，由于`n-x`属于`[1, n-1]`，返回的元素是`n-x`的me，即是全局me。

代码实现不必使用递归，用迭代代替就可以了。

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 1
        ans = nums[0]
        for num in nums[1:]:
            if count == 0:
                ans = num
                count = 1
            else:
                if ans != num:
                    count -= 1
                else:
                    count += 1
        return ans
```



## 448. Find All Numbers Disappeared in an Array

> Given an array of integers where `1 ≤ a[i] ≤ n` (`n` = size of array), some elements appear twice and others appear once.
>
> Find all the elements of [1, *n*] inclusive that do not appear in this array.
>
> Could you do it without extra space and in O(*n*) runtime? You may assume the returned list does not count as extra space.
>
> **Example:**
>
> ```
> Input:
> [4,3,2,7,8,2,3,1]
> 
> Output:
> [5,6]
> ```

这道题的技巧是用已有的空间，去记录计算结果。由于数组元素的取值在`[1, n]`之间，且数组的大小也是`n`，刚好可以用原数组来记录哪些值不在数组里。遍历数组，每发现一个新的值`n`，就将`nums[n-1]`这个元素取反。这样，数组中为负数的元素对应的下标，就会是那些出现过在数组中的数了。

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            idx = abs(nums[i]) - 1
            if nums[idx] > 0:
                nums[idx] = -nums[idx]
        return [i+1 for i in range(len(nums)) if nums[i] > 0]
```



## 49. Group Anagrams

> Given an array of strings, group anagrams together.
>
> **Example:**
>
> ```
> Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
> Output:
> [
>   ["ate","eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]
> ```

所谓的anagrams即是改变单词中字母顺序后，能够相等的两个单词。可以让每个单词的字母排序，anagrams的排序结果是相同的。也可以为每个单词计算一个26元素的数组`arr`，`arr[i]`表示第`i`个字母出现的次数。anagrams的`arr`也是相同的。这里可以直接把`arr`转换成一个字符串，比较anagrams时更为快捷。具体做法是对每个出现过的字母，将这个字母和它的频数一起添加进单词的`arr`字符串中。

其实将`arr`转换成字符串，可以看做一种哈希方法，将单词中出现的字母和它们的频数哈希成一个方便比较的指纹，然后和其他单词的指纹比较。我之前看过另一种哈希方法，就是让每个字母对应一个质数，然后将单词中所有字母对应的质数的乘积作为指纹。这样包含相同字母+字母频数的单词的指纹值时相同的单词是anagrams。不过这种做法容易让指纹值溢出。现在LeetCode好像会对溢出报错，所以这种哈希方法难以实行了。但是它的效率绝对会比我用的方法快很多。

```c++
class Solution {
   public:
    vector<vector<string>> groupAnagrams(vector<string> &strs) {
        if (strs.empty()) return {};
        map<string, vector<string>> m;
        for (string str : strs) {
            char arr[26] = {0};
            for (char c : str) ++arr[c - 'a'];
            string arr_s;
            for (int i = 0; i < 26; ++i) arr_s += (char)('a' + i) + to_string(arr[i]);
            if (m.find(arr_s) == m.end()) m[arr_s] = {};
            m[arr_s].push_back(str);
        }
        vector<vector<string>> rtn;
        for (map<string, vector<string>>::iterator it = m.begin();
             it != m.end(); ++it)
            rtn.push_back(it->second);
        return rtn;
    }
};
```



## 39. Combination Sum

> Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.
>
> The **same** repeated number may be chosen from `candidates` unlimited number of times.
>
> **Note:**
>
> - All numbers (including `target`) will be positive integers.
> - The solution set must not contain duplicate combinations.
>
> **Example 1:**
>
> ```
> Input: candidates = [2,3,6,7], target = 7,
> A solution set is:
> [
>   [7],
>   [2,2,3]
> ]
> ```
>
> **Example 2:**
>
> ```
> Input: candidates = [2,3,5], target = 8,
> A solution set is:
> [
>   [2,2,2,2],
>   [2,3,3],
>   [3,5]
> ]
> ```

一开始我是按下面的做法做的：

```python
class Solution:
    def combinationSum(self, candidates: 'List[int]', target: int) -> 'List[List[int]]':
        ans = []

        def recursive(i, sum_, seq):
            if i >= len(candidates) or candidates[i] + sum_ >= target:
                if sum_ + candidates[i] == target:
                    ans.append(seq + [candidates[i]])
                return
            recursive(i, sum_+candidates[i], seq+[candidates[i]])
            if i < len(candidates)-1:
                recursive(i + 1, sum_+candidates[i], seq+[candidates[i]])
                recursive(i + 1, sum_, seq.copy())

        recursive(0, 0, [])
        return ans
```

我的思路是：在每一步，有三种选择：

- 将当前元素添加进序列中，然后依然停留在当前元素；
- 将当前元素添加进序列中，然后移动到下一个元素；
- 直接跳过当前元素，移动到下一个元素。

这么做，有一个bug，就是同一个序列可能会被添加进答案中多次。比如说，`candidates = [2, 3], target = 5`。有两种路径，会将`[2, 3]`添加进答案中：

- 添加第一个2，留在第一个元素上 -> 跳过第一个元素，移动到第二个元素 -> 添加第二个元素。
- 添加第一个2，移动到第二个元素上 -> 添加第二个元素。

因此，答案中可能会有重复的序列。为了消除这种重复，应该这样改写代码：

```python
class Solution:
    def combinationSum(self, candidates: 'List[int]', target: int) -> 'List[List[int]]':
        ans = []

        def recursive(i, sum_, seq):
            if i >= len(candidates) or sum_ >= target:
                if sum_ == target:
                    ans.append(seq)
                return
            for j in range(i, len(candidates)):
                recursive(j, sum_+candidates[j], seq+[candidates[j]])

        recursive(0, 0, [])
        return ans
```

这个方法，可以这样理解：由`candidates[0:n]`组成的和为`target`的序列，可以分为`n`种，其中第`i`种为必包含`candidates[i]`，且只包含来自`candidates[i:n]`的元素的序列。因此，要统计出所有第`i`种序列，只需要统计出所有由`candidates[i:n]`组成的和为`target-candidates[i]`的序列，为它们append一个`candidates[i]`即可。要统计后者可以使用递归。



## 48. Rotate Image

> You are given an *n* x *n* 2D matrix representing an image.
>
> Rotate the image by 90 degrees (clockwise).
>
> **Note:**
>
> You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.
>
> **Example 1:**
>
> ```
> Given input matrix = 
> [
>   [1,2,3],
>   [4,5,6],
>   [7,8,9]
> ],
> 
> rotate the input matrix in-place such that it becomes:
> [
>   [7,4,1],
>   [8,5,2],
>   [9,6,3]
> ]
> ```
>
> **Example 2:**
>
> ```
> Given input matrix =
> [
>   [ 5, 1, 9,11],
>   [ 2, 4, 8,10],
>   [13, 3, 6, 7],
>   [15,14,12,16]
> ], 
> 
> rotate the input matrix in-place such that it becomes:
> [
>   [15,13, 2, 5],
>   [14, 3, 4, 1],
>   [12, 6, 8, 9],
>   [16, 7,10,11]
> ]
> ```

这道题更多的是需要多边界的掌控能力……可以看到，顺时钟旋转90度，其实就是对应位置的4个元素换了一下位置（比如，5 11 16 15，或者 1 10 2 14）。它们在位置上是有联系的。具体地说，`matrix[i][j]`会跟`matrix[j][-i - 1], matrix[-i - 1][-j - 1], matrix[-j - 1][i]`这三个元素换位。因此，只要访问左上角的`i, j`，再进行换位，就可以完成旋转。比较难的是确定边界。经过思考和debug，确定`i`的取值范围是`[0, ceil(len(matrix)/2)]`，而`j`的取值范围是`[0, len(matrix[0])//2]`。

```python
from math import ceil
class Solution:
    def rotate(self, matrix: 'List[List[int]]') -> None:
        if not matrix or not matrix[0]:
            return

        for i in range(ceil(len(matrix)/2)):
            for j in range(len(matrix[0]) // 2):
                matrix[i][j], matrix[j][-i - 1], matrix[-i - 1][-j - 1], matrix[-j - 1][i] = matrix[-j - 1][i], matrix[i][j], matrix[j][-i - 1], matrix[-i - 1][-j - 1]
```

[这个人](https://leetcode.com/problems/rotate-image/discuss/18884/Seven-Short-Solutions-(1-to-7-lines))把下标简化了一下，用`~i`代替`-i-1`，也是可以的。这个[答案](https://leetcode.com/problems/rotate-image/discuss/18872/A-common-method-to-rotate-the-image)提出了另外两种顺时钟旋转矩阵的方法。分别是：将矩阵的行上下翻转，再求其转置。



## 215. Kth Largest Element in an Array

> Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
>
> **Example 1:**
>
> ```
> Input: [3,2,1,5,6,4] and k = 2
> Output: 5
> ```
>
> **Example 2:**
>
> ```
> Input: [3,2,3,1,2,4,5,5,6] and k = 4
> Output: 4
> ```

这道题的直觉做法是维护一个大小为`k`的最小堆，将每个元素`push`进堆中，然后`pop`出`n-k`个，保留`k`个。剩下的最小元素就是第`k`大的元素。这种做法固然好，但是有一个更加合适的算法，称为[QuickSelect算法](https://en.wikipedia.org/wiki/Quickselect)。它有点像快排。逆序快排的一种形式是，选择一个`pivot`，然后将所有大于`pivot`的元素移动到数组前面，后面的元素就是小于等于`pivot`的。设共有`x`个元素比`pivot`大，将`pivot`这个元素和`arr[x]`交换，这样`arr[:x]`是比`pivot`大的元素，`arr[x+1:]`的元素不大于`pivot`。对`arr[:x]`和`arr[x+1:]`继续用快排，直到完全排好为止。事实上，如果当前轮的`pivot`被放在`arr[k-1]`位置上，可以看出共有`k-1`个元素比`pivot`大，`n-k+1`个元素不大于`pivot`。那么`pivot`就是第`k`大的元素了。这样在快排的过程中，可以在完全排序好之前知道第`k`大的元素。

另外，快排会递归地排序`arr[:x]`和`arr[x+1:]`两部分。但是，我们的目的是为了找到第`k`大的元素。`arr[:x]`中的元素都比`arr[x]`大。如果`x < k`，显然第`k`大的元素不可能在`arr[:x]`中。所以不必去排序`arr[:x]`了，只用关注`arr[x+1:]`即可。如果`x >= k`，显然第`k`大的元素是在`arr[:x]`之中。所以也不必去排序`arr[x+1:]`。这个过程就像二分查找，每次平均能排除一半的候选项。

不过，即使QuickSelect这个方法在理论上很美妙，但提交给LeetCode，它的性能比堆排序差多了……不明白是为什么。

```c++
// heap
class Solution {
   public:
    int findKthLargest(vector<int> &nums, int k) {
        std::priority_queue<int, std::vector<int>, std::greater<int>> pq;
        for (int num : nums) {
            pq.push(num);
            if (pq.size() > k) pq.pop();
        }
        return pq.top();
    }
};
// quick sort
class Solution {
    int qsort(vector<int> &arr, int l, int r, int k) {
        if (l >= r) return arr[l];
        int pivot = arr[r], p = l, tmp;
        for (int i = l; i <= r; ++i) {
            if (arr[i] > pivot) tmp = arr[i], arr[i] = arr[p], arr[p] = tmp, ++p;
        }
        tmp = arr[p], arr[p] = arr[r], arr[r] = tmp;
        // there is p elements greater than pivot
        if (p == k - 1) {
            return pivot;
        } else if (p < k) {
            // there are less than k elements greater than pivot
            // the answer cannot be among these p elements
            // so do not need to sort arr[:p]
            return qsort(arr, p + 1, r, k);
        } else {
            return qsort(arr, l, p - 1, k);
        }
    }
   public:
    int findKthLargest(vector<int> &nums, int k) {
        return qsort(nums, 0, nums.size()-1, k);
    }
};
```



## 287. Find the Duplicate Number

```c++
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Example 1:

Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
```

假设我们构造一个有`n+1`个节点的图，编号为`0~n`。对数组`arr`的每个元素`arr[i] == x`，我们在图中添加一条有向边，从节点`i`指向节点`x`。由于`arr[1:n+1]`共有`n`个元素，范围在`1~n`之间，所以这`n`个元素为节点`1`到`n`连接了共`n`条边。节点`1`到`n`之间必有环，否则边的数目不超过`n-1`。而节点`0`是无入度的，因为`arr`中没有值为`0`的元素。假设`arr[0] == y`。加上`0->y`这一条边，节点`1`到`n`中必有至少一个节点的入度大于1。假设这个节点的编号是`d`。由于有两条以上的有向边指向它，所以必有超过两个数组元素的值等于`d`，这意味着`d`就是我们要找的重复元素。也就是说，我们找重复元素的任务，等价于在图中找一个入度大于1的节点。

另一方面，从节点`0`出发，每次沿着一条边前进到下一个节点，肯定会走入一个环。这是因为每个节点都有出度（这条出边的目的节点号是节点对应的`arr[i]`的值）。环的入口在节点`1`到`n`之中，且它的入度大于1。这个节点的编号就是重复元素。至此，我们把寻找重复元素的任务，化成了在有环图中寻找环入口节点的任务。

要寻找环的入口，可以用[Floyd's Tortoise and Hare Algorithm](https://en.wikipedia.org/wiki/Cycle_detection)。这个算法是比较常见的，我就不介绍了。

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];  // go to next node
            fast = nums[nums[fast]];    // 2 steps
        } while (slow != fast);     // meet in circle
        // suppose distance from start to entrance of circle is x
        // distance from entrance to meet point is y
        // distance from meet point to entrance is z
        // then, slow goes (x + y) steps
        // fast goes (x + y + z + y) steps (1 whole circle)
        // then: 2 * (x + y) == (x + 2 * y + z) -> x == z
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```



## 102. Binary Tree Level Order Traversal

> Given a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).
>
> For example:
> Given binary tree `[3,9,20,null,null,15,7]`,
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
>
> 
>
> return its level order traversal as:
>
> ```
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
> ```

层次遍历是非常基本的知识。用一个队列来存储当前层的所有节点。设当前层有`x`个节点。在对该层遍历时，从队列中`pop`出`x`个节点，对它们访问后，将它们的非空孩子压入队列中。在遍历完最后一层后，队列会变空。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root) return {};
        queue<TreeNode*> level;
        vector<vector<int>> rtn;
        level.push(root);
        while (!level.empty()) {
            rtn.push_back(vector<int>());
            int level_num = level.size();
            for (int i = 0; i < level_num; ++i) {
                TreeNode *node = level.front(); level.pop();
                rtn.back().push_back(node->val);
                if (node->left) level.push(node->left);
                if (node->right) level.push(node->right);
            }
        }
        return rtn;
    }
};
```



## 21. Merge Two Sorted Lists

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
>
> **Example:**
>
> ```
> Input: 1->2->4, 1->3->4
> Output: 1->1->2->3->4->4
> ```

为了方便，可以设置一个虚拟的头节点。同时遍历`l1 l2`链表，比较它们，将较小的节点接到虚拟头结点开始的链表中。

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode *head = new ListNode(0); // virtual head
        ListNode *curr = head;
        while (l1 && l2) {
            if (l1->val < l2->val) curr->next = l1, l1 = l1->next;
            else curr->next = l2, l2 = l2->next;
            curr = curr->next;
        }
        if (l1) curr->next = l1;
        if (l2) curr->next = l2;
        curr = head->next;
        delete head;
        return curr;
    }
};
```



## 62. Unique Paths

> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).
>
> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
>
> How many possible unique paths are there?
>
> ![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)
> Above is a 7 x 3 grid. How many possible unique paths are there?
>
>  
>
> **Example 1:**
>
> ```
> Input: m = 3, n = 2
> Output: 3
> Explanation:
> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
> 1. Right -> Right -> Down
> 2. Right -> Down -> Right
> 3. Down -> Right -> Right
> ```
>
> **Example 2:**
>
> ```
> Input: m = 7, n = 3
> Output: 28
> ```



非常基础的动态规划问题。用`dp[i][j]`表示到达`grid[i][j]`的路径数，那么

```python
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

```python
def uniquePaths(self, m: int, n: int) -> int:
	dp = [[0 for _ in range(n)] for _ in range(m)]
	for i in range(m):
	    for j in range(n):
	        if i == 0 and j == 0:
	            dp[i][j] = 1
	        else:
	            if i > 0:
	                dp[i][j] += dp[i-1][j]
	            if j > 0:
	                dp[i][j] += dp[i][j-1]
	return dp[-1][-1]
```

因为这个动态规划的累加是有序的，所以至多用一个一维数组就够了，用来记录`dp[i-1][j]`：

```python
def uniquePaths(self, m: int, n: int) -> int:
	dp = [0 for _ in range(n)]
	for i in range(m):
	    for j in range(n):
	        if i == 0 and j == 0:
	            dp[j] = 1
	        else:
	            if i > 0:
	                # dp[i][j] += dp[i-1][j]. do nothing
	                pass
	            if j > 0:
	                dp[j] += dp[j-1]
	return dp[-1]
```

时间复杂度为$O(mn)$。



## 64. Minimum Path Sum

> Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.
>
> **Note:** You can only move either down or right at any point in time.
>
> **Example:**
>
> ```
> Input:
> [
>   [1,3,1],
>   [1,5,1],
>   [4,2,1]
> ]
> Output: 7
> Explanation: Because the path 1→3→1→1→1 minimizes the sum.
> 
> ```

这道题可以用动态规划解决。另`dp[i][j]`表示走到`grid[i][j]`的最小花费。显然有`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。这里向62题一样，用一个一维的`dp`数组就可以了。

```c++
#define min(x, y) ( (x) < (y) ? (x) : (y) )
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if (!grid.size() || !grid[0].size()) return 0;
        // dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        vector<int> dp(grid[0].size(), 0);
        dp[0] = grid[0][0];
        for (int j = 1; j < grid[0].size(); ++j) dp[j] = dp[j-1] + grid[0][j];
        for (int i = 1; i < grid.size(); ++i) {
            dp[0] += grid[i][0];
            for (int j = 1; j < grid[0].size(); ++j)
                dp[j] = min(dp[j-1], dp[j]) + grid[i][j];
        }
        return dp.back();
    }
};
```



## 312. Burst Balloons

> Given `n` balloons, indexed from `0` to `n-1`. Each balloon is painted with a number on it represented by array `nums`. You are asked to burst all the balloons. If the you burst balloon `i` you will get `nums[left] * nums[i] * nums[right]` coins. Here `left` and `right` are adjacent indices of `i`. After the burst, the `left` and `right` then becomes adjacent.
>
> Find the maximum coins you can collect by bursting the balloons wisely.
>
> **Note:**
>
> - You may imagine `nums[-1] = nums[n] = 1`. They are not real therefore you can not burst them.
> - 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100
>
> **Example:**
>
> ```
> Input: [3,1,5,8]
> Output: 167 
> Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
>              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
> ```

这是一个动态规划问题。为了方便，在数组的首尾各添加一个1，作为所谓的`nums[-1] nums[n]`。令`dp[i][j]`表示子数组`nums[i:j+1]`的气球全部爆炸以后能获得的最大金币数。在所有气球中，如果`nums[p]`是最后爆炸的，那么炸掉它获得的金币数是`nums[p]`，炸掉它左边的所有气球获得的金币数是`dp[0][p]`，炸掉右边的所有气球获得的金币数是`dp[p+1][-1]`。因此，就有`dp[0][-1] == dp[0][p] + dp[p+1][-1] + nums[p]`。尝试所有的`p`，可以求出一个最大的`dp[0][-1]`，便是最终的答案。而求`dp[0][p] dp[p+1][-1]`，可以用类似的思路递归求出。

```c++
class Solution {
    vector<vector<int>> dp;
    int recursive(vector<int> &nums, int i, int j) {
        // calculate dp[i][j]
        if (dp[i][j] != -1) return dp[i][j];    // already calculated
        if (i + 1 == j) return 0;  // no balloons left
        // try p
        int max_coin = -1, curr_coin;
        for (int p = i + 1; p < j; ++p) {
            curr_coin = recursive(nums, i, p) + recursive(nums, p, j) + nums[i] * nums[j] * nums[p];
            if (curr_coin > max_coin) max_coin = curr_coin;
        }
        dp[i][j] = max_coin;
        return max_coin;
    }
public:
    int maxCoins(vector<int>& nums) {
        if (nums.empty()) return 0;
        nums.push_back(1), nums.insert(nums.begin(), 1);
        dp = vector<vector<int>>(nums.size(), vector<int>(nums.size(), -1));
        return recursive(nums, 0, nums.size()-1);
    }
};
```



## 96. Unique Binary Search Trees

> Given *n*, how many structurally unique **BST's** (binary search trees) that store values 1 ... *n*?
>
> **Example:**
>
> ```
> Input: 3
> Output: 5
> Explanation:
> Given n = 3, there are a total of 5 unique BST's:
> 
>    1         3     3      2      1
>     \       /     /      / \      \
>      3     2     1      1   3      2
>     /     /       \                 \
>    2     1         2                 3
> ```

这是一道动态规划题。设`dp[i]`是节点数为`i`的二叉搜索树的数量。节点为`i`的二叉搜索树的根节点可以在`1~i`之间，设它的根节点为`x`，那么`1~x-1`这些节点必定在它的左子树中，`x+1~i`则在右子树上。所以它的左子树有`x-1`个节点，右子树有`i-x`个节点。左子树的形态共有`dp[x-1]`种，右子树的形态共有`dp[i-x]`种。因此，以`x`为根，节点数为`n`的二叉搜索树共有`dp[x-1] * dp[i-x]`种。

```c++
class Solution {
public:
    int numTrees(int n) {
        if (n <= 1) return n;
        vector<int> dp(n+1, 0);
        dp[0] = 1;  // empty tree
        for (int i = 1; i <= n; ++i) {
            for (int x = 1; x <= i; ++x) {
                dp[i] += dp[x-1] * dp[i-x];
            }
        }
        return dp[n];
    }
};
```





## 198. 213. 337. House Robber I & II & III

> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.
>
> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.
>
> **Example 1:**
>
> ```
> Input: [1,2,3,1]
> Output: 4
> Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
>              Total amount you can rob = 1 + 3 = 4.
> ```
>
> **Example 2:**
>
> ```
> Input: [2,7,9,3,1]
> Output: 12
> Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
>              Total amount you can rob = 2 + 9 + 1 = 12.
> ```

第一道题可以用动态规划解决。设`dp[i]`是在`nums[:i+1]`之中抢劫，能抢到的最大金额。对于`nums[i]`，有两种可能，要么抢劫它，那么`dp[i] = dp[i-2] + nums[i]`；要么不抢劫它，那么`dp[i] = dp[i-1]`。这两种可能的最大值即是`dp[i]`的值。可以用两个变量来记录`dp[i-2]`和`dp[i-1]`，那么就不用`dp`向量了。

```c++
#define max(x, y) ( (x) > (y) ? (x) : (y) )
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        for (int i = 1; i < dp.size(); ++i) {
            dp[i] = nums[i];
            if (i > 1) dp[i] += dp[i-2];
            dp[i] = max(dp[i], dp[i-1]);
        }
        return dp.back();
    }
};
```

> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.
>
> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.
>
> **Example 1:**
>
> ```
> Input: [2,3,2]
> Output: 3
> Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
>              because they are adjacent houses.
> ```
>
> **Example 2:**
>
> ```
> Input: [1,2,3,1]
> Output: 4
> Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
>              Total amount you can rob = 1 + 3 = 4.
> ```

和I几乎一样，只是`nums[0]`和`nums[-1]`挨在一起，不能同时被偷。那么，可以分别计算`nums[0:-1]`和`nums[1:]`被偷后的最大金额，再比较它们，取最大值为答案。

```c++
class Solution {
    int _rob(vector<int>& nums, int l, int r) {
        // max rob num of nums[l:r]
        vector<int> dp(r - l, 0);
        dp[0] = nums[l];
        for (int i = 1; i < dp.size(); ++i) {
            dp[i] = nums[i+l];
            if (i > 1) dp[i] += dp[i-2];
            dp[i] = max(dp[i], dp[i-1]);
        }
        return dp.back();
    }
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        if (nums.size() == 1) return nums[0];
        int rob1 = _rob(nums, 0, nums.size()-1), rob2= _rob(nums, 1, nums.size());
        return max(rob1, rob2);
    }
};

```

> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.
>
> Determine the maximum amount of money the thief can rob tonight without alerting the police.
>
> **Example 1:**
>
> ```
> Input: [3,2,3,null,3,null,1]
> 
>      3
>     / \
>    2   3
>     \   \ 
>      3   1
> 
> Output: 7 
> Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
> ```
>
> **Example 2:**
>
> ```
> Input: [3,4,5,1,3,null,1]
> 
>      3
>     / \
>    4   5
>   / \   \ 
>  1   3   1
> 
> Output: 9
> Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
> ```

这次房子不是线性排列的，而是呈二叉树形状排列的。不能同时偷相邻的两个房子，即是不能同时偷一个父节点和它的孩子。思路和前面两个基本一样。令`dp[node]`为以节点`node`为根的子树所能抢到的最大金额。对于一个节点`node`，要么抢它，获得最多`node->val + dp[node->left->left] + dp[node->left->right] + dp[node->right->left] + dp[node->right->right]`这么多钱（`node`的两个孩子不能抢，只能跨代抢）；要么不抢，获得最多`dp[node->left] + dp[node->right]`这么多钱。这两个数值相比较，取较大的作为`dp[node]`。

```c++
class Solution {
    std::map<TreeNode*, int> dp;
    int get_dp(TreeNode *node) {
        if (dp.find(node) != dp.end()) return dp[node];
        int not_rob = 0;
        if (node->left) not_rob += get_dp(node->left);
        if (node->right) not_rob += get_dp(node->right);
        int rob = node->val;
        if (node->left) {
            if (node->left->left) rob += get_dp(node->left->left);
            if (node->left->right) rob += get_dp(node->left->right);
        }
        if (node->right) {
            if (node->right->left) rob += get_dp(node->right->left);
            if (node->right->right) rob += get_dp(node->right->right);
        }
        dp[node] = max(not_rob, rob);
        return dp[node];
    }
public:
    int rob(TreeNode* root) {
        if (!root) return 0;
        return get_dp(root);
    }
};
```





## 121.122.123.188.309.714 Best Time to Buy and Sell Stock I & II & III & IV & Cooldown & Transaction Fee

> Say you have an array for which the *i*th element is the price of a given stock on day *i*.
>
> If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
>
> Note that you cannot sell a stock before you buy one.
>
> **Example 1:**
>
> ```
> Input: [7,1,5,3,6,4]
> Output: 5
> Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
>              Not 7-1 = 6, as selling price needs to be larger than buying price.
> ```
>
> **Example 2:**
>
> ```
> Input: [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.
> ```

遍历每一天的股票价格，在当天能够获得的最大收益，是当天价格减去过去最低的价格。所以用一个变量来记住过去最低的价格，比较今天是否可以卖出比以往更高的收益即可。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price = 0x7fffffff, max_profit = 0;
        for (int price: prices) {
            if (price - min_price > max_profit) max_profit = price - min_price;
            if (price < min_price) min_price = price;
        }
        return max_profit;
    }
};
```

> You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
>
> **Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).
>
> **Example 1:**
>
> ```
> Input: [7,1,5,3,6,4]
> Output: 7
> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
>              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
> ```
>
> **Example 2:**
>
> ```
> Input: [1,2,3,4,5]
> Output: 4
> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
>              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
> ```
>
> **Example 3:**
>
> ```
> Input: [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.
> ```

如果第`i+1`天的股价比第`i`天高，且手中有股票，那么肯定不会在第`i`天卖，而是等到第`i+1`天卖。同样的，如果第`i+1`天股价比第`i`天低，那肯定不会留到第`i+1`天才卖。可以给股价变化画一个曲线图。在股价上升时我们持有股票；在股价下降时空仓，这样每次股价的上升我们都能赚到，每次股价下跌我们都能避免损失。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        int profit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i] > prices[i-1])
                profit += prices[i] - prices[i-1];
        }
        return profit;
    }
};
```

> You may complete at most *two* (*k*) transactions.
>
> **Example 1:**
>
> ```
> Input: [3,3,5,0,0,3,1,4]
> Output: 6
> Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
>              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
> ```
>
> **Example 2:**
>
> ```
> Input: [1,2,3,4,5]
> Output: 4
> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
>              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
>              engaging multiple transactions at the same time. You must sell before buying again.
> ```
>
> **Example 3:**
>
> ```
> Input: [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.
> ```

III和IV是类似的。III规定最多可以买卖2次，IV规定最多可以买卖`k`次。可以用动态规划来解决这个问题。令`dp[k][i]`为在第`1~i`天中，进行至多`k`次交易能获得的最大收益。易知`dp`的转移公式是`dp[k][i] = max(dp[k][i-1], prices[i-1]-prices[j-1]+dp[k-1][j-1])`。第一项，`dp[k][i-1]`，表示第`i`天不交易，所以能获得的最大收益和前一天的一样；`prices[i-1]-prices[j-1]+dp[k-1][j-1]`表示今天卖出第`j`天买入的股票。由于对每个`i`，需要对`1~i-1`之间的所有`j`求`prices[i-1]-prices[j-1]+dp[k-1][j-1]`，然后计算最大值，会导致时间复杂度高达`O(kn^2)`，提交超时。通过观察，可以发现，求`prices[i-1]-prices[j-1]+dp[k-1][j-1]`大部分是冗余的。可以在`i`的迭代中记录`max_j(prices[i-1]-prices[j-1]+dp[k-1][j-1])`，以省去内层循环。

```c++
// 为了方便，从1开始算天数，而非通常的从0开始算天数
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        // dp[k][i] = max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1])
        vector<vector<int>> dp(3, vector<int>(prices.size()+1, 0));
        for (int k = 1; k <= 2; ++k) {
            for (int i = 2; i <= prices.size(); ++i) {
                int max_profit = dp[k][i-1], curr_profit;
                for (int j = 1; j < i; ++j) {
                    curr_profit = prices[i-1] - prices[j-1] + dp[k-1][j-1];
                    if (curr_profit > max_profit) max_profit = curr_profit;
                }
                dp[k][i] = max_profit;
            }
        }
        return dp[2][prices.size()];
    }
};
// 上面的答案时间复杂度为O(kn^2)，超时了。按照原文的建议，删改了最内层循环
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        // dp[k][i] = max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1])
        vector<vector<int>> dp(3, vector<int>(prices.size()+1, 0));
        for (int k = 1; k <= 2; ++k) {
            // -prices[j-1]+dp[k-1][j-1]
            int max_profit = -prices[0], curr_profit;
            for (int i = 2; i <= prices.size(); ++i) {
                curr_profit = -prices[i-2] + dp[k-1][i-2];
                if (curr_profit > max_profit) max_profit = curr_profit;
                // prices[i-1]-prices[j-1]+dp[k-1][j-1]
                curr_profit = prices[i-1] + max_profit;
                dp[k][i] = curr_profit > dp[k][i-1] ? curr_profit : dp[k][i-1];
            }
        }
        return dp[2][prices.size()];
    }
};
```

IV规定最多可以买卖`k`次。简单地将III的答案改造了一下，会发现在`k`较大时，生成`dp`数组（`k*n`维）可能不够内存，而且循环轮数也过多。因此在III的基础上，还需要对`k`进行优化。显然，`dp`被顺序遍历，是可以优化成一个一维数组的。其次，在`k >= n/2`时，问题就退化到了II，可以在线性时间内解决。

```c++
class Solution {
    int maxProfit_II(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        int profit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i] > prices[i-1])
                profit += prices[i] - prices[i-1];
        }
        return profit;
    }
public:
    int maxProfit(int K, vector<int> &prices) {
        if (prices.size() <= 1) return 0;
        if (K >= prices.size()/2) return maxProfit_II(prices);
        // dp[k][i] = max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1])
        vector<int> dp_k(vector<int>(prices.size()+1, 0));
        vector<int> dp_k_1(vector<int>(prices.size()+1, 0));    // dp[k-1]
        for (int k = 1; k <= K; ++k) {
            // -prices[j-1]+dp[k-1][j-1]
            int max_profit = -prices[0], curr_profit;
            for (int i = 2; i <= prices.size(); ++i) {
                curr_profit = -prices[i-2] + dp_k_1[i-2];
                if (curr_profit > max_profit) max_profit = curr_profit;
                // prices[i-1]-prices[j-1]+dp[k-1][j-1]
                curr_profit = prices[i-1] + max_profit;
                dp_k[i] = curr_profit > dp_k[i-1] ? curr_profit : dp_k[i-1];
            }
            dp_k_1 = dp_k;
        }
        return dp_k[prices.size()];
    }
};
```

> You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:
>
> - After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
>
> **Example:**
>
> ```
> Input: [1,2,3,0,2]
> Output: 3 
> Explanation: transactions = [buy, sell, cooldown, buy, sell]
> ```

这题刷新了我的知识范围，[这篇回答](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking))使用了状态机来构造动态规划转移公式，非常有启发性。如下图，在某一时刻，我们处于三个状态中的某一个中：

- `S0`：没有持有股票；
- `S1`：持有股票，等待抛售；
- `S2`：刚刚卖完股票，正在冷却。

我们用三个数组，分别记录在第`i`天时处于这三个状态的最大获利金额。这三个`dp`数组的转移公式显而易见：

- `S0[i] = max(S0[i-1], S2[i-1])`
- `S1[i] = max(S0[i-1] - prices[i], S1[i-1])`，从`S0`买入`prices[i]`
- `S2[i] = S1[i-1] + prices[i]`，从`S1`卖出`prices[i]`

![leetcode_stock_cooldown](https://two2er.github.io/img/others/leetcode_stock_cooldown.png)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        vector<int> S0(prices.size()), S1(prices.size()), S2(prices.size());
        S0[0] = 0, S1[0] = -prices[0], S2[0] = -0x7fffffff;      // cannot be at S2
        for (int i = 1; i < prices.size(); ++i) {
            S0[i] = std::max(S0[i-1], S2[i-1]);
            S1[i] = std::max(S0[i-1] - prices[i], S1[i-1]);
            S2[i] = S1[i-1] + prices[i];
        }
        return std::max(S0.back(), S2.back());
    }
};
```

> You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. 
>
> **Example 1:**
>
> ```
> Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
> Output: 8
> Explanation: The maximum profit can be achieved by:
> Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
> ```

有了上面`cooldown`状态机的启发，做这一题就非常简单了^_^这次只需要`S0`和`S1`两个状态，在`S1`（持有股票）转移到`S0`（没有持有股票）状态时，要额外扣除手续费。状态机图比`cooldown`简单很多。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if (prices.size() <= 1) return 0;
        vector<int> S0(prices.size()), S1(prices.size());
        S0[0] = 0, S1[0] = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            S0[i] = std::max(S0[i-1], S1[i-1] + prices[i] - fee);
            S1[i] = std::max(S0[i-1] - prices[i], S1[i-1]);
        }
        return S0.back();
    }
};
// 对内存进行优化，只需要两个变量来记录状态数据
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if (prices.size() <= 1) return 0;
        int S0 = 0, S1 = -prices[0], tmp;
        for (int i = 1; i < prices.size(); ++i) {
            tmp = S0;
            S0 = std::max(S0, S1 + prices[i] - fee);
            S1 = std::max(tmp - prices[i], S1);
        }
        return S0;
    }
};
```



## 11. Container With Most Water

> Given *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
>
> **Note:** You may not slant the container and *n* is at least 2.
>
>  
>
> ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)
>
> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
>
>  
>
> **Example:**
>
> ```
> Input: [1,8,6,2,5,4,8,3,7]
> Output: 49
> ```

选择两块挡板，水的体积由挡板组成的容器的高度（较矮的挡板的高度）和宽度（挡板的距离）相乘得到。首先我们考虑由最左和最右两块挡板组成的容器。如果最左的挡板`a`比最右的挡板`b`矮，那么容器`a b`的高度即是`a`的高度。假设存在一个容器体积比`a b`组成的容器体积大，它可不可能由`a`组成？不可能，因为这个容器的宽度肯定比`a b`小，而且它的高度也不大于`a`，所以它的体积肯定比`a b`小。所以，我们在继续寻找更大容器的过程中，就不必再考虑挡板`a`了。接下来考虑的是宽度仅次于`a b`的容器`c b`（`c`为`a`右边的挡板）。根据同样的思路，不断缩小搜索空间。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int low = 0, high = height.size()-1, max_area = 0;
        while (low < high) {
            max_area = max(max_area, (high - low) * min(height[low], height[high]));
            if (height[low] < height[high]) low++;
            else high--;
        }
        return max_area;
    }
};
```



## 394. Decode String

> Given an encoded string, return its decoded string.
>
> The encoding rule is: `k[encoded_string]`, where the *encoded_string* inside the square brackets is being repeated exactly *k* times. Note that *k* is guaranteed to be a positive integer.
>
> You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
>
> Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, *k*. For example, there won't be input like `3a` or `2[4]`.
>
> **Examples:**
>
> ```
> s = "3[a]2[bc]", return "aaabcbc".
> s = "3[a2[c]]", return "accaccacc".
> s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
> ```

这道题可以用递归来做，也可以用栈来做。用栈更加复杂，需要先分析什么东西要被LIFO地保存，什么时候被取出。考虑下面这种情况：`3[ab4[bc]d]`。在进入最里层的括号（`4[bc]`）后，我们需要一个变量`cur`来存储最里层包含的字符串，在收集完成后将它复制4次，和它外层的字符串（`ab`）相连接。外层不完整的字符串适合放在栈中，在它下一层的字符串成功获取并复制后，将它们拼接，然后继续完善这层的字符串。这层的字符串完成后，从栈中取出它上一层的不完整字符串，将它们拼接，然后继续完成上一层的字符串……可以看出，将某一层未完成的字符串放入栈中是LIFO的。

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<int> repeat_num;
        stack<string> incomplete;

        string cur, last;
        int repeat;
        for (int i = 0, len = s.length(); i < len; ++i) {
            if (isdigit(s[i])) {
                int val = 0;
                while (isdigit(s[i]))
                    val = val * 10 + (s[i] - '0'), ++i;
                --i;
                repeat_num.push(val);
            } else if (s[i] == '[') {
                incomplete.push(cur);
                cur = "";
            } else if (s[i] == ']') {
                repeat = repeat_num.top();
                last = incomplete.top();
                repeat_num.pop(), incomplete.pop();
                while (repeat--) last += cur;
                cur = last;
            } else cur += s[i];
        }
        return cur;
    }
};
```





## 543. Diameter of Binary Tree

> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the **longest** path between any two nodes in a tree. This path may or may not pass through the root.
>
> **Example:**
> Given a binary tree
>
> ```
>           1
>          / \
>         2   3
>        / \     
>       4   5    
> ```
>
> 
>
> Return **3**, which is the length of the path [4,2,1,3] or [5,2,1,3].
>
> **Note:** The length of path between two nodes is represented by the number of edges between them.

这题可以用类似动态规划的思路做。假设有一条路径通过节点`node`，并且`node`是这条路径上最高的节点，那么要让这条路径最长，它肯定通达了`node`左右子树的最深处。令叶子节点的高度为`1`，那么这条路径的最长长度，其实就是左右子树的高度和。从叶子结点向上，逐层地求出以某个节点为最高节点的路径的最长长度。这个过程可以整合在为树求高度的过程之中。

```c++
class Solution {
    int ans;
    int getHeight(TreeNode *node) {
        if (!node) return 0;
        int left_h = getHeight(node->left), right_h = getHeight(node->right);
        if (left_h + right_h > ans) ans = left_h + right_h;
        return std::max(left_h, right_h) + 1;
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 0;
        getHeight(root);
        return ans;
    }
};
```



## 621. Task Scheduler

> Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.
>
> However, there is a non-negative cooling interval **n** that means between two **same tasks**, there must be at least n intervals that CPU are doing different tasks or just be idle.
>
> You need to return the **least** number of intervals the CPU will take to finish all the given tasks.
>
>  
>
> **Example:**
>
> ```
> Input: tasks = ["A","A","A","B","B","B"], n = 2
> Output: 8
> Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.
> ```

显然，时钟周期数和最频繁的任务的任务数是有关的。假设最频繁的任务`A`有`x`个，那么需要的时钟周期起码是`(x - 1) * (n + 1) + 1`个。在这段时间的间隙里，可以插入其它任务。思路类似于贪心算法，先做任务数最大的任务，然后做数量次之的任务。

```c++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        unordered_map<char,int> mp;
        int count = 0;
        for(auto e : tasks) {
            mp[e]++;
            count = max(count, mp[e]);
        }
        int ans = (count-1) * (n+1);
        for(auto e : mp) if (e.second == count) ans++;
        // counterexample: AAABBBCCDDEF, n = 2
        return max((int)tasks.size(), ans);
    }
};
```



## 42. Trapping Rain Water

> Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
>
> ![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)
> The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!
>
> **Example:**
>
> ```
> Input: [0,1,0,2,1,0,1,3,2,1,2,1]
> Output: 6
> ```

凭直觉就能感受到，第`i`个槽可以存的水的水位是它左边的槽最高高度和右边的槽的最高高度的较小值。减去这个水槽的高度，就是能存的水的体积。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
        vector<int> max_left(height.size()), max_right(height.size());
        int cur_max = 0;
        for (int i = 0; i < height.size(); ++i) {
            max_left[i] = cur_max;
            if (height[i] > cur_max) cur_max = height[i];
        }
        cur_max = 0;
        for (int i = height.size()-1; i >= 0; --i) {
            max_right[i] = cur_max;
            if (height[i] > cur_max) cur_max = height[i];
        }
        int rtn = 0;
        for (int i = 0; i < height.size(); ++i) {
            cur_max = std::min(max_left[i], max_right[i]);
            if (cur_max > height[i]) rtn += cur_max - height[i];
        }
        return rtn;
    }
};
```



## 114. Flatten Binary Tree to Linked List

> Given a binary tree, flatten it to a linked list in-place.
>
> For example, given the following tree:
>
> ```
>     1
>    / \
>   2   5
>  / \   \
> 3   4   6
> ```
>
> The flattened tree should look like:
>
> ```
> 1
>  \
>   2
>    \
>     3
>      \
>       4
>        \
>         5
>          \
>           6
> ```

先把左子树和右子树变成链表，然后将它们和根节点连接起来，整棵树就变成了一个链表。因此，可以递归地将左右子树先变成链表，再将根节点和它们连接起来。

```c++
class Solution {
public:
    void flatten(TreeNode* node) {
        if (!node) return;
        flatten(node->left), flatten(node->right);
        TreeNode *curr = node->left;
        if (!curr) return;
        while (curr->right) curr = curr->right;
        curr->right = node->right;
        node->right = node->left, node->left = nullptr;
    }
};
```

附另一种写法，非常地简洁巧妙。

```c++
class Solution {
  TreeNode *prev = NULL;
public:
  void flatten(TreeNode* root) {
    if (root == NULL) return;
    flatten(root->right), flatten(root->left);
    root->left = NULL, root->right = prev;
    prev = root;
  }
};
```



## 494. Target Sum

> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols `+` and `-`. For each integer, you should choose one from `+` and `-` as its new symbol.
>
> Find out how many ways to assign symbols to make sum of integers equal to target S.
>
> **Example 1:**
>
> ```
> Input: nums is [1, 1, 1, 1, 1], S is 3. 
> Output: 5
> Explanation: 
> 
> -1+1+1+1+1 = 3
> +1-1+1+1+1 = 3
> +1+1-1+1+1 = 3
> +1+1+1-1+1 = 3
> +1+1+1+1-1 = 3
> 
> There are 5 ways to assign symbols to make the sum of nums be target 3.
> ```

这道题用DFS来做，可以AC，但是效率不高。这位[兄弟](https://leetcode.com/problems/target-sum/discuss/97334/Java-(15-ms)-C%2B%2B-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation)提出了一个更好的办法，他将数组分成了`P`和`N`两个部分，其中`P`的符号将是正的，`N`的符号将是负的。这道题要求`sum(P) - sum(N) = target`，两边同时加上`sum(nums)`，可以得到`2 * sum(P) = target + sum(nums)`。因此，问题就归化成了一个等价问题：在`nums`中找出若干数，使其和为`(target + sum(nums)) / 2`。这就变成了一个01背包问题：在`nums`的物品中找出若干物品，使其填满大小为`(target + sum(nums)) / 2`。

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum_ =  accumulate(nums.begin(), nums.end(), 0);
        if (sum_ < S || -sum_ > S) return 0;
        sum_ += S;
        if (sum_ % 2 == 1) return 0;    // should be even
        sum_ /= 2;
        vector<int> dp(sum_+1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = sum_; j >= nums[i]; --j)
                dp[j] = dp[j] + dp[j-nums[i]];
        }
        return dp[sum_];
    }
};
```



## 105. Construct Binary Tree from Preorder and Inorder Traversal

> Given preorder and inorder traversal of a tree, construct the binary tree.
>
> **Note:**
> You may assume that duplicates do not exist in the tree.
>
> For example, given
>
> ```
> preorder = [3,9,20,15,7]
> inorder = [9,3,15,20,7]
> ```
>
> Return the following binary tree:
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```

一棵树的前序遍历序列，按照`[根节点 [左子树遍历序列] [右子树遍历序列]]`这样排列。一棵树的中序遍历序列，按照`[[左子树遍历序列] 根节点 [右子树遍历序列]]`这样排列。我们可以从前序遍历序列的第一个元素发现根节点的值。在中序遍历序列中定位根节点，其左边序列的元素个数就是左子树的节点个数。在前序遍历序列中顺序截取这个长度的序列，就是左子树前序遍历的序列。从左子树前序遍历序列和左子树中序遍历序列，又可以递归地构造左子树。同理，右子树也能从其前序遍历序列和中序遍历序列递归地构造。

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder,
                        int pl = -1, int pr = -1, int il = -1, int ir = -1) {
        if (preorder.empty() || inorder.empty()) return nullptr;
        // construct with preorder[pl:pr], inorder[il:ir]
        if (pl == -1) pl = 0, il = 0, pr = preorder.size(), ir = inorder.size();
        if (pl == pr || il == ir) return nullptr;
        TreeNode *root = new TreeNode(preorder[pl]);
        int root_pos = std::find(inorder.begin()+il, inorder.end()+ir, preorder[pl]) - inorder.begin();
        int left_len = root_pos - il;
        root->left = buildTree(preorder, inorder, pl+1, pl+1+left_len, il, il+left_len);
        root->right = buildTree(preorder, inorder, pl+1+left_len, pr, root_pos+1, ir);
        return root;
    }
};
```





## 70. Climbing Stairs

> You are climbing a stair case. It takes *n* steps to reach to the top.
>
> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
>
> **Note:** Given *n* will be a positive integer.
>
> **Example 1:**
>
> ```
> Input: 2
> Output: 2
> Explanation: There are two ways to climb to the top.
> 1. 1 step + 1 step
> 2. 2 steps
> ```
>
> **Example 2:**
>
> ```
> Input: 3
> Output: 3
> Explanation: There are three ways to climb to the top.
> 1. 1 step + 1 step + 1 step
> 2. 1 step + 2 steps
> 3. 2 steps + 1 step
> ```

这是典型的动态规划问题。令`dp[i]`等于爬`i`阶的方法数。显然，`dp[i] = dp[i-1] + dp[i-2]`。可以用两个变量来代替`dp[i-1]`和`dp[i-2]`进行优化。

```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        // dp[1], dp[2]
        int dp_1 = 1, dp_2 = 2, dp;
        for (int i = 3; i <= n; ++i) {
            dp = dp_1 + dp_2;
            dp_1 = dp_2, dp_2 = dp;
        }
        return dp_2;
    }
};
```





## 53. Maximum Subarray

> Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
>
> **Example:**
>
> ```
> Input: [-2,1,-3,4,-1,2,1,-5,4],
> Output: 6
> Explanation: [4,-1,2,1] has the largest sum = 6.
> ```

假设`nums[i:j]`是和最大的序列。那么，它的前缀`nums[i:k], k < j`，和肯定不会小于0。因为如果有前缀和小于0，那么去掉它得到的序列，和会更大。因此，可以线性地遍历`nums`，同时累加元素，如果当前累加值小于0，则舍弃截止到当前的元素之前的序列，因为往后的序列不可能带上之前的序列作为前缀。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cur = 0, max_ = -0x7fffffff;
        for (int n: nums) {
            cur += n;
            if (cur > max_) max_ = cur;
            if (cur < 0) cur = 0;
        }
        return max_;
    }
};
```





## 101. Symmetric Tree

> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
>
> For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:
>
> ```
>     1
>    / \
>   2   2
>  / \ / \
> 3  4 4  3
> ```
>
>  
>
> But the following `[1,2,2,null,3,null,3]` is not:
>
> ```
>     1
>    / \
>   2   2
>    \   \
>    3    3
> ```

代码胜过千言万语……

```c++
class Solution {
  bool recursive(TreeNode *A, TreeNode *B) {
    if (A == NULL && B == NULL) return true;
    // not symmetric
    if (A == NULL || B == NULL) return false;
    if (A->val != B->val) return false;
    return recursive(A->left, B->right) && recursive(A->right, B->left);
  }
public:
  bool isSymmetric(TreeNode* root) {
    if (root == NULL) return true;
    return recursive(root->left, root->right);
  }
};
```





## 297. Serialize and Deserialize Binary Tree

> Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
>
> Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.
>
> **Example:** 
>
> ```
> You may serialize the following tree:
> 
>     1
>    / \
>   2   3
>      / \
>     4   5
> 
> as "[1,2,3,null,null,4,5]"
> ```
>
> **Clarification:** The above format is the same as [how LeetCode serializes a binary tree](https://leetcode.com/faq/#binary-tree). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
>
> **Note:** Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

对树进行前序遍历，每访问一个节点，就向序列加入该节点的值。如果是空节点，就向序列加入一个表示空节点的符号。这样得到的前序遍历序列可以唯一地表示一棵树。在反序列化时，依然是前序遍历，每碰到一个数值则创建一个节点，碰到空节点符号则跳过当前分支。为了效率，我偷偷改了原题的接口，把返回值从`string`类型改成了`char*`类型。我把`int`数组指针显式转换成了`char*`指针，在反序列化时将其变回`int*`即可。不过这种做法存在内存泄漏的隐患，代码风格并不好。要认真做题的话还是看[这个](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74259/Recursive-preorder-Python-and-C%2B%2B-O(n))。

```c++
class Codec {
    vector<int> sequence;
    int* arr;
    void preorder(TreeNode* node) {
        if (!node) {
            sequence.push_back(0x7fffffff);
            return;
        }
        sequence.push_back(node->val);
        preorder(node->left);
        preorder(node->right);
    }

    TreeNode* de_preorder() {
        int val = *arr++;
        if (val == 0x7fffffff) return nullptr;
        TreeNode* root = new TreeNode(val);
        root->left = de_preorder(), root->right = de_preorder();
        return root;
    }

   public:
    // Encodes a tree to a single string.
    char* serialize(TreeNode* root) {
        sequence.clear();
        preorder(root);
        int *arr = new int[sequence.size() + 1];
        std::copy(sequence.begin(), sequence.end(), arr);
        return (char*) arr;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(char *data) {
        arr = (int*)data;
        TreeNode* node = de_preorder();
        delete[] data;
        return node;
    }
};
```





## 17. Letter Combinations of a Phone Number

> Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.
>
> A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
>
> ![img](http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)
>
> **Example:**
>
> ```
> Input: "23"
> Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
> ```

没啥好说的，非常简单的一个回溯问题。

```c++
class Solution {
    static vector<string> map;
    vector<string> rtn;
    
    void dfs(string &digits, string &prefix, int i) {
        if (i >= digits.length()) {
            rtn.push_back(prefix);
            return;
        }
        for (char c : map[digits[i]-'2']) {
            prefix += c;
            dfs(digits, prefix, i + 1);
            prefix.pop_back();
        }
    }
public:
    vector<string> letterCombinations(string digits) {
        if (!digits.length()) return {};
        rtn.clear();
        string prefix = "";
        dfs(digits, prefix, 0);
        return rtn;
    }
};
vector<string> Solution::map = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
```





## 200. Number of Islands

> Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
>
> **Example 1:**
>
> ```
> Input:
> 11110
> 11010
> 11000
> 00000
> 
> Output: 1
> ```
>
> **Example 2:**
>
> ```
> Input:
> 11000
> 11000
> 00100
> 00011
> 
> Output: 3
> ```

每发现一个格子是陆地，就把它置为`0`，然后DFS它的上下左右相邻格子。这样在完整访问完一块陆地后，它所有的格子都变成`0`，在后续的搜索中就不会再被找到。

```c++
class Solution {
    void explore_island(vector<vector<char>> &grid, int i, int j) {
        // set the area of the island to '0'
        grid[i][j] = '0';
        if (i < grid.size() - 1 && grid[i+1][j] == '1') explore_island(grid, i + 1, j);
        if (i > 0 && grid[i-1][j] == '1') explore_island(grid, i - 1, j);
        if (j < grid[0].size() - 1 && grid[i][j+1] == '1') explore_island(grid, i, j + 1);
        if (j > 0 && grid[i][j-1] == '1') explore_island(grid, i, j - 1);
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        if (!grid.size() || !grid[0].size()) return 0;
        int count = 0;
        for (int i = 0, ie = grid.size(); i < ie; ++i) {
            for (int j = 0, je = grid[0].size(); j < je; ++j) {
                if (grid[i][j] == '1') {
                    explore_island(grid, i, j);
                    ++count;
                }
            }
        }
        return count;
    }
};
```





## 1. Two Sum

> Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.
>
> You may assume that each input would have ***exactly\*** one solution, and you may not use the *same* element twice.
>
> **Example:**
>
> ```
> Given nums = [2, 7, 11, 15], target = 9,
> 
> Because nums[0] + nums[1] = 2 + 7 = 9,
> return [0, 1].
> ```

用一个哈希表保存遍历过的数和它的下标。在访问一个元素`nums[i]`时，先看看哈希表里是否储存了`target-nums[i]`，如果有，就返回它们的下标。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> my_map;
        for (int i = 0; i < nums.size(); ++i) {
            if (my_map.find(target-nums[i]) != my_map.end())
                return {my_map[target-nums[i]], i};
            my_map[nums[i]] = i;
        }
        return {};
    }
};
```





## 437. Path Sum III

> You are given a binary tree in which each node contains an integer value.
>
> Find the number of paths that sum to a given value.
>
> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
>
> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.
>
> **Example:**
>
> ```
> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8
> 
>       10
>      /  \
>     5   -3
>    / \    \
>   3   2   11
>  / \   \
> 3  -2   1
> 
> Return 3. The paths that sum to 8 are:
> 
> 1.  5 -> 3
> 2.  5 -> 2 -> 1
> 3. -3 -> 11
> ```

这题我做的方法比较笨，我在访问一个节点时，求出了通往它所有子嗣的路径的路径和，然后判断这里面是否有和等于`sum`的路径。非常低效，不值一提。

这个[答案](https://leetcode.com/problems/path-sum-iii/discuss/91888/18ms-Fast-One-Pass-C%2B%2B-Solution)是我见过的最好的。在访问一个节点`node`时，将它的节点值修改为从根节点到这个节点的路径的路径和。如果它的祖先之中，有一个节点到根节点的路径和等于`node->val - sum`，则它们之间的路径和为`node->val - (node->val - sum) = sum`。所以，在访问`node`时，如果能事先知道它的祖先之中有多少个节点的节点值为`node->val - sum`，就可以马上知道以`node`为路径终点的路径中有多少条的路径和是`sum`。这里用了一个哈希表来保存祖先的路径和。代码结构非常巧妙，艺高人胆大。

```
class Solution {
public:
    int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {
        if (!root) return 0;
        root->val += pre;
        int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);
        store[root->val]++;
        res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);
        store[root->val]--;
        return res;
    }

    int pathSum(TreeNode* root, int sum) {
        unordered_map<int, int> store;
        return help(root, sum, store, 0);
    }
};
```





## 75. Sort Colors

> Given an array with *n* objects colored red, white or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white and blue.
>
> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
>
> **Note:** You are not suppose to use the library's sort function for this problem.
>
> **Example:**
>
> ```
> Input: [2,0,2,1,1,0]
> Output: [0,0,1,1,2,2]
> ```

维护两个指针`low`和`high`。规定`nums[:low]`应该全是`0`，`nums[high+1:]`应该全是2。每访问到一个`0`，就将它和`nums[low]`互换，并让`low`加一。每访问到一个`2`，就将它和`nums[high]`互换，并让`high`减一。在访问到`high`后，就没有未访问的元素了。`low`到`high`之间的元素应该全是`1`。这里要注意的是当前访问元素`mid`的位置。`mid`应该始终不小于`low`。当和`nums[high]`互换以后，`mid`不应该加一，因为换来的这个数（新的`nums[mid]`）还没有被访问过。

```c++
class Solution {
    public:
      void sortColors(vector<int>& nums) {
        if (nums.size() == 0) return;
        int low = 0, high = nums.size() - 1, mid = 0;
        while (mid <= high) {
          if (nums[mid] == 0) {
            swap(nums[mid], nums[low++]);
            mid = low;
          }
          else if (nums[mid] == 2)
            swap(nums[mid], nums[high--]);
          else ++mid;
        }
      }
};
```





## 279. Perfect Squares

> Given a positive integer *n*, find the least number of perfect square numbers (for example, `1, 4, 9, 16, ...`) which sum to *n*.
>
> **Example 1:**
>
> ```
> Input: n = 12
> Output: 3 
> Explanation: 12 = 4 + 4 + 4.
> ```
>
> **Example 2:**
>
> ```
> Input: n = 13
> Output: 2
> Explanation: 13 = 4 + 9.
> ```

这是一个[多重背包问题](https://two2er.github.io/pages/algorithms/2019-10-08-unusual-algorithms)。可以放入背包的物品为`1 4 9 ...`等所有不大于`n`的平方数。每个物品可以放入背包无限次。令`dp[i][v]`为用前`i`件物品填满大小为`v`的背包的方法数，则其转移方程为`dp[i][v] = min(dp[i-1][v], dp[i][v-nums[i]] + 1)`，即要么第`i`件物品一件不放，要么至少放入一件。多重背包的做法效率好像不是很好，在讨论区有其他的动态规划视角[回答](https://leetcode.com/problems/perfect-squares/discuss/71512/Static-DP-C%2B%2B-12-ms-Python-172-ms-Ruby-384-ms)，不过这些回答并没有多重背包解法普适。

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> nums;
        for (int i = 1, ii; ; ++i) {
            ii = i * i;
            if (ii < n) nums.push_back(ii);
            else if (ii == n) return 1;
            else break;
        }
        vector<int> dp(n+1, 0x7fffffff);
        dp[0] = 0;
        for (int i = 0; i < nums.size(); ++i) {
            for (int v = nums[i]; v <= n; ++v) {
                dp[v] = std::min(dp[v], dp[v-nums[i]] + 1);
            }
        }
        return dp[n];
    }
};
```











## 416. Partition Equal Subset Sum

> Given a **non-empty** array containing **only positive integers**, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
>
> **Example 1:**
>
> ```
> Input: [1, 5, 11, 5]
> 
> Output: true
> 
> Explanation: The array can be partitioned as [1, 5, 5] and [11].
> ```
>
> **Example 2:**
>
> ```
> Input: [1, 2, 3, 5]
> 
> Output: false
> 
> Explanation: The array cannot be partitioned into equal sum subsets.
> ```

这道题其实就是一个01背包问题，要求在数组中挑出若干个数，使其和为数组和`sum`的二分之一，等价于从物品中挑选出若干物品填满一个大小为`sum/2`的背包。令`dp[i][j]`表示用前`i`件物品，是否能填满一个大小为`j`的背包。转移公式为`dp[i][j] = dp[i-1][j] || dp[i-1][j-arr[i]]`，即如果能用前`i-1`件物品填满`j`大小的背包，或者`j-arr[i]`大小的背包，就能用前`i`件物品填满`j`大小的背包。

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum_ =  accumulate(nums.begin(), nums.end(), 0);
        if (sum_ % 2 == 1) return false;    // should be even
        sum_ = sum_ / 2;
        vector<bool> dp(sum_+1, false);
        dp[0] = true;   // for convenience
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = sum_; j >= nums[i]; --j)
                dp[j] = dp[j] || dp[j-nums[i]];
        }
        return dp[sum_];
    }
};
```

由于这道题的`dp`数组元素只要一个比特，所以可以用一个bitset来代替vector数组。用bitset还有一个好处，就是内层循环`for (int j = sum_; ...)`不需要真的去遍历了，只需要对bitset做位移操作即可，`dp[j-nums[i]]`相当于`dp << nums[i]`。具体地操作请看代码：

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum_ =  accumulate(nums.begin(), nums.end(), 0);
        if (sum_ % 2 == 1) return false;    // should be even
        sum_ = sum_ / 2;
        const int MAX_NUM = 100;
        const int MAX_ARRAY_SIZE = 200;
        // sum_ <= MAX_NUM * MAX_ARRAY_SIZE / 2
        bitset<MAX_NUM * MAX_ARRAY_SIZE / 2 + 1> dp(1);
        for (int n: nums)
            dp |= dp << n;
        return dp[sum_];
    }
};
```







































