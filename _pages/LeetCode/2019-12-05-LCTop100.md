---
layout: post
title: LeetCode-链表
excerpt: "LeetCode问题的解答：链表"
categories: [Algorithm]
comments: true


---

##  617. Merge Two Binary Trees 

> Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
>
> You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.
>
> **Example 1:**
>
> ```
> Input: 
> 	Tree 1                     Tree 2                  
>           1                         2                             
>          / \                       / \                            
>         3   2                     1   3                        
>        /                           \   \                      
>       5                             4   7                  
> Output: 
> Merged tree:
> 	     3
> 	    / \
> 	   4   5
> 	  / \   \ 
> 	 5   4   7
> ```

这道题可以递归地同时访问`t1`和`t2`。在它们的当前根节点都不为None时，新建一个节点，其值为两个根节点值的和；在某个根节点为None时，新建一个树，其为另一个根节点所属子树的拷贝（在我的代码中，我没有做这一步，因为偷懒了，而且时间会更快……但这是不对的）；如果两个根节点都是None，则返回None。

```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1 and not t2:
            return None
        elif not t1:
            return t2
        elif not t2:
            return t1
        else:
            node = TreeNode(t1.val + t2.val)
            node.left = self.mergeTrees(t1.left, t2.left)
            node.right = self.mergeTrees(t1.right, t2.right)
            return node
```



##  338. Counting Bits 

> Given a non negative integer number **num**. For every numbers **i** in the range **0 ≤ i ≤ num** calculate the number of 1's in their binary representation and return them as an array.
>
> **Example 1:**
>
> ```
> Input: 2
> Output: [0,1,1]
> ```
>
> **Example 2:**
>
> ```
> Input: 5
> Output: [0,1,1,2,1,2]
> ```

**(1)** DP方法：

一个数如果是奇数，那么它的二进制表示会比它右移一位的数的二进制表示多一个一；否则一的个数相等。

```python
class Solution:
    def countBits(self, num: int):
        dp = [0 for _ in range(num+1)]
        for i in range(1, num+1):
            if i % 2 == 0:
                dp[i] = dp[i//2]
            else:
                dp[i] = dp[i//2] + 1
        return dp
```

**(2)** 找规律：

`[2^n, 2^(n+1))`的数字数目，等于`[0:2^n)`的数字数目（因为在`[0:2^n)`的每个数的二进制表示前面加一个1，就会变成`[2^n, 2^(n+1))`里的数）。因此，可以先求去一个最小的`n`，使得`2^n>num`，然后每次使用`[0:2^i)`中的数的1的个数，去求`[2^i, 2^(i+1))`中的数的1的个数（只需加一即可），并将结果添加至结果数组里。最后，取结果数组的前`num+1`项。

```python
class Solution:
    def countBits(self, num: int):
        if num == 0:
            return [0]
        # find a n which is the smallest integer that 2^n >= num
        n, tmp = -1, num
        while tmp != 0:
            n += 1
            tmp >>= 1
        ans = [0, 1]
        # construct ans[:2^n]
        while n > 0:
            ans.extend([1+x for x in ans])
            n -= 1
        return ans[:num+1]
```



##  104. Maximum Depth of Binary Tree 

> Given a binary tree, find its maximum depth.
>
> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
>
> **Note:** A leaf is a node with no children.
>
> **Example:**
>
> Given binary tree `[3,9,20,null,null,15,7]`,
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
>
> return its depth = 3.

非常基础的递归。

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

这是DFS，或者也可以用层次遍历/BFS。因为所有节点都必须被访问一次，所以没有时间上的区别。



## 136. Single Number

```python
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,1]
Output: 1
Example 2:

Input: [4,1,2,1,2]
Output: 4
```

把全部数XOR起来，剩下的数就是the single one。这是因为相同的数异或为0，而0与其他数异或为其他数。

```python
from functools import reduce

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x^y, nums)
```



## 406. Queue Reconstruction by Height

> Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers `(h, k)`, where `h` is the height of the person and `k` is the number of people in front of this person who have a height greater than or equal to `h`. Write an algorithm to reconstruct the queue.
>
> **Note:**
> The number of people is less than 1,100.
>
> **Example**
>
> ```
> Input:
> [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
> 
> Output:
> [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
> ```

一个比较矮的人无论是站在一个更高的人的前面或者后面，对他的`k`值都不会有影响。因此，可以考虑用插入的方式构造队列：先插入最高的人，然后插入第二高的，然后是第三高……直到插入了所有人。插入一个比较矮的人，对队列中已经存在的人的`k`是没有影响的。因此，只需要为这个比较矮的人寻找一个合适的位置，让他取到对的`k`值，就能让队列中已有的人的`k`值都是正确的。就像这样，不断插入拥有对的`k`值的人，最终排好的队列中的人的`k`值都会是对的。

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        ans = []
        for each in people:
            ans.insert(each[1], each)
        return ans
```

```c++
class Solution {
   public:
    vector<vector<int>> reconstructQueue(vector<vector<int>> &people) {
        if (people.size() == 0) return {};
        std::sort(
            people.begin(), people.end(), [](vector<int> &x, vector<int> &y) {
                return x[0] > y[0] || (x[0] == y[0] && x[1] < y[1]);
            });
        vector<vector<int>> rtn;
        for (auto &p : people) {
            rtn.insert(rtn.begin() + p[1], p);
        }
        return rtn;
    }
};
```




## 739. Daily Temperatures

> Given a list of daily temperatures `T`, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead.
>
> For example, given the list of temperatures `T = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`.
>
> **Note:** The length of `temperatures` will be in the range `[1, 30000]`. Each temperature will be an integer in the range `[30, 100]`.

这种求一个方向上的递增或递减的题，大部分可以用栈解决。使用一个栈`stack`，用来在访问完每个温度值后存入该温度值的索引。在访问一个新的温度值`t`时，如果它跟栈顶温度值索引对应的温度相比更大时，便进行`pop`，并在栈顶索引对应的输入数组位置上记录数值。简单地说，`stack`里留存的是那些还没有找到接下来的更暖气温的气温值索引。在它们找到了一个更暖的气温后，便从栈中弹出，并记录花费的天数。

```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        stack = []
        ans = [0 for _ in range(len(T))]
        for i, t in enumerate(T):
            while stack and T[stack[-1]] < t:
                ans[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return ans
```




## 226. Invert Binary Tree

> Invert a binary tree.
>
> **Example:**
>
> Input:
>
> ```
>      4
>    /   \
>   2     7
>  / \   / \
> 1   3 6   9
> ```
>
> Output:
>
> ```
>      4
>    /   \
>   7     2
>  / \   / \
> 9   6 3   1
> ```

传说中Homebrew作者面试谷歌时做不出而导致被挂的题……其实很简单嘛，可能是一时忘了二叉树的结构？……感觉这道题在递归之中确实是偏简单，把当前访问节点的左右节点互换，然后递归地处理左右子树就行了。

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```




## 94. Binary Tree Inorder Traversal

> Given a binary tree, return the *inorder* traversal of its nodes' values.
>
> **Example:**
>
> ```
> Input: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
> 
> Output: [1,3,2]
> ```

参见[另一个页面](https://two2er.github.io/pages/algorithms/2019-10-08-unusual-algorithms)。




## 46. Permutations

> Given a collection of **distinct** integers, return all possible permutations.
>
> **Example:**
>
> ```
> Input: [1,2,3]
> Output:
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]
> ```

这道题最符合直觉的做法就是递归。假设通过递归，获得了`nums[1:]`的所有置换后，要获得`nums`的置换，只需要将`nums[0]`插入到`nums[1:]`的置换的各个位置上即可。或者也可以换种思路：依次取`nums`中的一个元素`nums[i]`，计算剩下元素`nums[:i]+nums[i+1:]`的所有置换。然后在这些置换的最前添加`nums[i]`（也就是计算所有以`nums[i]`开头的置换）。这两种方法简单地想，应该有差不多的复杂度（不过在LeetCode的测试用例上第一种会省时一点。但是算法复杂度应该是一样的）

```PYTHON
class Solution:
    def permute(self, nums: 'List[int]') -> 'List[List[int]]':
        if len(nums) <= 1:
            return [nums]
        pers = self.permute(nums[1:])
        ans = []
        for each in pers:
            for i in range(len(each)+1):
                ans.append(each[:i] + [nums[0]] + each[i:])
        return ans
```

```python
class Solution:
    def permute(self, nums: 'List[int]') -> 'List[List[int]]':
        if len(nums) <= 1:
            return [nums]
        ans = []
        for i in range(len(nums)):
            pers = self.permute(nums[:i] + nums[i+1:])
            ans.extend([[nums[i]] + each for each in pers])
        return ans
```

下面是[Permutations II](https://leetcode.com/problems/permutations-ii/)，`nums`中会有重复，结果需要去重。做法的思路是一样的，只是需要先对`nums`进行排序，在碰到重复元素时跳过即可。

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        if len(nums) <= 1:
            return [nums]
        ans = []
        nums.sort()
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            pers = self.permuteUnique(nums[:i] + nums[i+1:])
            ans.extend([[nums[i]] + each for each in pers])
        return ans
```



## 647. Palindromic Substrings

> Given a string, your task is to count how many palindromic substrings in this string.
>
> The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
>
> **Example 1:**
>
> ```
> Input: "abc"
> Output: 3
> Explanation: Three palindromic strings: "a", "b", "c".
> ```
>
>  
>
> **Example 2:**
>
> ```
> Input: "aaa"
> Output: 6
> Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
> ```

这道题我已知的有两种做法。第一种是我用的DP方法。令`dp[i][j]`表示子串`s[i:j+1]`是否为回文。对于所有`i`，肯定有`dp[i][i] = 1`。然后依次计算`s`的长度为`length`的子串是否回文。如果`s[i+1:i+length-1]`是回文，且`s[i] == s[i+length]`，那么`s[i:i+length+1]`也会是回文。这种做法的时间复杂度是`O(n^2)`。不过这种方法不如下面一种[方法](https://leetcode.com/problems/palindromic-substrings/discuss/105689/Java-solution-8-lines-extendPalindrome)。下面的方法在`s[i:j]`不为回文的情况下，就不会再计算`s[i-1:j+1]`、`s[i-2:j+2]`……了，在效率上更佳。

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        if not s:
            return 0
        # dp[i][j] = num of palindromic substrings in s[i:j+1]
        dp = [[0 for _ in s] for _ in s]
        for i in range(len(s)):
            dp[i][i] = 1
        for length in range(1, len(s)):
            for i in range(len(s)):
                end = i + length
                if end >= len(s):
                    continue
                if s[i] == s[end] and (length == 1 or dp[i+1][end-1]):
                    dp[i][end] = 1
        return sum([sum(each) for each in dp])
```

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        if not s:
            return 0

        self.count = 0
        def extend(left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                self.count += 1
                left, right = left - 1, right + 1
                
        for i in range(len(s)):
            extend(i, i)
            extend(i, i + 1)
        return self.count
```



## 22. Generate Parentheses

> Given *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
>
> For example, given *n* = 3, a solution set is:
>
> ```
> [
>   "((()))",
>   "(()())",
>   "(())()",
>   "()(())",
>   "()()()"
> ]
> ```

这是一个非常简单的回溯问题。在回溯过程中，保持以下规律：

- 每添加一个"("，就必须添加一个")"
- "("的总数为`n`
- “)"的个数在子串`s[:i]`中不能比"("的个数多

就可以筛选掉那些不符合要求的置换。

```python
class Solution:
    def generateParenthesis(self, n: int) -> 'List[str]':
        if n == 0:
            return []
        ans = []

        def recursive(left, right, s):
            if left == 0 and right == 0:
                ans.append(s)
            if left > 0:
                recursive(left - 1, right + 1, s + '(')
            if right > 0:
                recursive(left, right - 1, s + ')')

        recursive(n, 0, '')
        return ans
```



## 206. Reverse Linked List

>Reverse a singly linked list.
>
>**Example:**
>
>```
>Input: 1->2->3->4->5->NULL
>Output: 5->4->3->2->1->NULL
>```

这道题非常经典……见了无数次。首先是递归版本。递归地将当前头部的下个节点为头部的链表翻转。然后翻转链表的尾部——即当前头部的下一个节点——的`next`设为头部，而头部的`next`设为`None`即可。另外，递归还可以像[这样](https://leetcode.com/problems/reverse-linked-list/discuss/58125/In-place-iterative-and-recursive-Java-solution)，在递归过程中按顺序翻转节点间的指向（从头到尾，而我的是从尾到头）。

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head
```

迭代版本使用3个指针`prev`，`cur`和`nex`来分别指向当前节点的前一个节点、当前节点、当前节点下一个节点。在迭代过程中，将`cur.next`设为`prev`，然后三个指针分别向前移动一个节点（`nex`的意义是为了防止改变`cur.next`后无法到达原链表中当前节点的下一个节点）。

```python
class Solution:    
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        prev, cur, nex = None, head, head.next
        while nex:
            cur.next = prev
            prev, cur, nex = cur, nex, nex.next
        cur.next = prev
        return cur
```



## 347. Top K Frequent Elements

> Given a non-empty array of integers, return the **k** most frequent elements.
>
> **Example 1:**
>
> ```
> Input: nums = [1,1,1,2,2,3], k = 2
> Output: [1,2]
> ```
>
> **Example 2:**
>
> ```
> Input: nums = [1], k = 1
> Output: [1]
> ```

如果用Counter来计算频率的话，那代码就太简单了。在排序频率时可以优化。因为所有数的频率的范围在`[1, len(nums)]`之间，所以可以用桶`bucket[i]`来装频率为`i`的所有数。这样算法复杂度可以降到`O(n)`。不过可能是桶使用列表来装数，不如builtin函数高效，用桶的实现甚至比下面的代码还慢。

```python
from collections import Counter

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        ctr = Counter(nums)
        return [x[0] for x in sorted(ctr.items(), key=lambda x: -x[1])[:k]]
```



## 238. Product of Array Except Self

> Given an array `nums` of *n* integers where *n* > 1,  return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.
>
> **Example:**
>
> ```
> Input:  [1,2,3,4]
> Output: [24,12,8,6]
> ```

题目的意思是，`ans[i]`是`nums[:i] + nums[i+1:]`中元素的累乘。因此，可以从左到右线性地算出各个`nums[:i]`的累乘，再从右到左算出各个`nums[i+1:]`的累乘。然后，`ans[i]`等于对应位置的左右累乘的积。这样算法复杂度就为`O(n)`。下面的做法用了两个数组记录左右累乘，来回共遍历了3趟。[这个做法](https://leetcode.com/problems/product-of-array-except-self/discuss/65622/Simple-Java-solution-in-O(n)-without-extra-space)把计算从右到左累乘和计算结果两步合在一起了，并且少用一个数组，大有可借鉴之处。

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        left, right = [1 for _ in nums], [1 for _ in nums]
        for i in range(1, len(nums)):
            left[i] = left[i-1] * nums[i-1]
        for i in range(len(nums)-2, -1, -1):
            right[i] = right[i+1] * nums[i+1]
        for i in range(len(nums)):
            left[i] = left[i] * right[i]
        return left
```

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        left, right = [1 for _ in nums], 1
        for i in range(1, len(nums)):
            left[i] = left[i-1] * nums[i-1]
        for i in range(len(nums)-1, -1, -1):
            left[i] = left[i] * right
            right = right * nums[i]
        return left
```



## 78. Subsets

> Given a set of **distinct** integers, `nums`, return all possible subsets (the power set).
>
> **Note:** The solution set must not contain duplicate subsets.
>
> **Example:**
>
> ```
> Input: nums = [1,2,3]
> Output:
> [
>   [3],
>   [1],
>   [2],
>   [1,2,3],
>   [1,3],
>   [2,3],
>   [1,2],
>   []
> ]
> ```

这题是典型的回溯。关于回溯，讨论区有个人总结了一些LeetCode上的[回溯题](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))。我下面的做法比较符合直觉，不过也可以像链接中那样，用循环代替一层递归，这样可能会比较省空间。

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        
        def recursive(arr, i):
            if i >= len(nums):
                ans.append(arr.copy())
            else:
                arr.append(nums[i])
                recursive(arr, i+1)
                arr.pop()
                recursive(arr, i+1)
        
        recursive([], 0)
        return ans
```

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        
        def recursive(arr, i):
            ans.append(arr.copy())
            for j in range(i, len(nums)):
                arr.append(nums[j])
                recursive(arr, j+1)
                arr.pop()
        
        recursive([], 0)
        return ans
```

下面是[Subsets II](https://leetcode.com/problems/subsets-ii/)，`nums`中的元素会重复，要求要去重。思路是一样的，只是回溯时需要跳过重复的元素。

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort()
        
        def recursive(arr, i):
            ans.append(arr.copy())
            for j in range(i, len(nums)):
                if j > i and nums[j] == nums[j-1]:
                    continue
                arr.append(nums[j])
                recursive(arr, j+1)
                arr.pop()
        
        recursive([], 0)
        return ans
```



## 283. Move Zeroes

> Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.
>
> **Example:**
>
> ```
> Input: [0,1,0,3,12]
> Output: [1,3,12,0,0]
> ```

使用一个指针`i`，`nums[:i]`都是非0的数，且保留了原来的顺序。然后遍历`nums`，每发现一个非0的数，就跟`nums[i]`调换，并且让`i`加一。这道题的思路跟`low, high`指针（或者`left, right`指针）操作一个线性数组的题目是一样的。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        i = 0
        for j, num in enumerate(nums):
            if num != 0:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
```



## 169. Majority Element

> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.
>
> You may assume that the array is non-empty and the majority element always exist in the array.
>
> **Example 1:**
>
> ```
> Input: [3,2,3]
> Output: 3
> ```
>
> **Example 2:**
>
> ```
> Input: [2,2,1,1,1,2,2]
> Output: 2
> ```

这道题的解法，是一种叫[Boyer–Moore majority vote algorithm]([https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm#:~:targetText=The%20Boyer%E2%80%93Moore%20majority%20vote,linear%20time%20and%20constant%20space.&targetText=In%20its%20simplest%20form%2C%20the,the%20elements%20of%20the%20input.](https://en.wikipedia.org/wiki/Boyer–Moore_majority_vote_algorithm#:~:targetText=The Boyer–Moore majority vote,linear time and constant space.&targetText=In its simplest form%2C the,the elements of the input.))的算法。附带一个这个算法的[证明](https://www.quora.com/What-is-the-proof-of-correctness-of-Moores-voting-algorithm)。

在起始时，将`nums[0]`当做majority element（me）。`count`的意义是“在已经访问的元素中，当前me的数目比不是me的数目多的个数”。故起始时`count`为1。顺序访问数组，如果访问到的数等于当前me，则`++count`；否则`--count`。

可以用数学归纳法证明。如果`nums.size() == 1`，显然返回的元素（第一个元素）是正确答案。

设`nums.size()`在`[1, n-1]`以内时返回的元素是正确答案。

如果`count == 0`，说明目前已访问的元素中，没有一个的个数比其他的总数大。设已经访问了`x`个元素，则全局me在这`x`个元素中至多出现了`x/2`次。由于me的个数大于`n/2`，所以在剩下的`n-x`个元素中，它至少会出现`(n-x)/2+1`次，即它在剩下的`n-x`个元素中依然是me。那么对剩下的`n-x`个元素递归地调用函数`majorityElement`，由于`n-x`属于`[1, n-1]`，返回的元素是`n-x`的me，即是全局me。

代码实现不必使用递归，用迭代代替就可以了。

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 1
        ans = nums[0]
        for num in nums[1:]:
            if count == 0:
                ans = num
                count = 1
            else:
                if ans != num:
                    count -= 1
                else:
                    count += 1
        return ans
```



## 448. Find All Numbers Disappeared in an Array

> Given an array of integers where `1 ≤ a[i] ≤ n` (`n` = size of array), some elements appear twice and others appear once.
>
> Find all the elements of [1, *n*] inclusive that do not appear in this array.
>
> Could you do it without extra space and in O(*n*) runtime? You may assume the returned list does not count as extra space.
>
> **Example:**
>
> ```
> Input:
> [4,3,2,7,8,2,3,1]
> 
> Output:
> [5,6]
> ```

这道题的技巧是用已有的空间，去记录计算结果。由于数组元素的取值在`[1, n]`之间，且数组的大小也是`n`，刚好可以用原数组来记录哪些值不在数组里。遍历数组，每发现一个新的值`n`，就将`nums[n-1]`这个元素取反。这样，数组中为负数的元素对应的下标，就会是那些出现过在数组中的数了。

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            idx = abs(nums[i]) - 1
            if nums[idx] > 0:
                nums[idx] = -nums[idx]
        return [i+1 for i in range(len(nums)) if nums[i] > 0]
```



## 49. Group Anagrams

> Given an array of strings, group anagrams together.
>
> **Example:**
>
> ```
> Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
> Output:
> [
>   ["ate","eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]
> ```

所谓的anagrams即是改变单词中字母顺序后，能够相等的两个单词。可以让每个单词的字母排序，anagrams的排序结果是相同的。也可以为每个单词计算一个26元素的数组`arr`，`arr[i]`表示第`i`个字母出现的次数。anagrams的`arr`也是相同的。这里可以直接把`arr`转换成一个字符串，比较anagrams时更为快捷。具体做法是对每个出现过的字母，将这个字母和它的频数一起添加进单词的`arr`字符串中。

其实将`arr`转换成字符串，可以看做一种哈希方法，将单词中出现的字母和它们的频数哈希成一个方便比较的指纹，然后和其他单词的指纹比较。我之前看过另一种哈希方法，就是让每个字母对应一个质数，然后将单词中所有字母对应的质数的乘积作为指纹。这样包含相同字母+字母频数的单词的指纹值时相同的单词是anagrams。不过这种做法容易让指纹值溢出。现在LeetCode好像会对溢出报错，所以这种哈希方法难以实行了。但是它的效率绝对会比我用的方法快很多。

```c++
class Solution {
   public:
    vector<vector<string>> groupAnagrams(vector<string> &strs) {
        if (strs.empty()) return {};
        map<string, vector<string>> m;
        for (string str : strs) {
            char arr[26] = {0};
            for (char c : str) ++arr[c - 'a'];
            string arr_s;
            for (int i = 0; i < 26; ++i) arr_s += (char)('a' + i) + to_string(arr[i]);
            if (m.find(arr_s) == m.end()) m[arr_s] = {};
            m[arr_s].push_back(str);
        }
        vector<vector<string>> rtn;
        for (map<string, vector<string>>::iterator it = m.begin();
             it != m.end(); ++it)
            rtn.push_back(it->second);
        return rtn;
    }
};
```



## 39. Combination Sum

> Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.
>
> The **same** repeated number may be chosen from `candidates` unlimited number of times.
>
> **Note:**
>
> - All numbers (including `target`) will be positive integers.
> - The solution set must not contain duplicate combinations.
>
> **Example 1:**
>
> ```
> Input: candidates = [2,3,6,7], target = 7,
> A solution set is:
> [
>   [7],
>   [2,2,3]
> ]
> ```
>
> **Example 2:**
>
> ```
> Input: candidates = [2,3,5], target = 8,
> A solution set is:
> [
>   [2,2,2,2],
>   [2,3,3],
>   [3,5]
> ]
> ```

一开始我是按下面的做法做的：

```python
class Solution:
    def combinationSum(self, candidates: 'List[int]', target: int) -> 'List[List[int]]':
        ans = []

        def recursive(i, sum_, seq):
            if i >= len(candidates) or candidates[i] + sum_ >= target:
                if sum_ + candidates[i] == target:
                    ans.append(seq + [candidates[i]])
                return
            recursive(i, sum_+candidates[i], seq+[candidates[i]])
            if i < len(candidates)-1:
                recursive(i + 1, sum_+candidates[i], seq+[candidates[i]])
                recursive(i + 1, sum_, seq.copy())

        recursive(0, 0, [])
        return ans
```

我的思路是：在每一步，有三种选择：

- 将当前元素添加进序列中，然后依然停留在当前元素；
- 将当前元素添加进序列中，然后移动到下一个元素；
- 直接跳过当前元素，移动到下一个元素。

这么做，有一个bug，就是同一个序列可能会被添加进答案中多次。比如说，`candidates = [2, 3], target = 5`。有两种路径，会将`[2, 3]`添加进答案中：

- 添加第一个2，留在第一个元素上 -> 跳过第一个元素，移动到第二个元素 -> 添加第二个元素。
- 添加第一个2，移动到第二个元素上 -> 添加第二个元素。

因此，答案中可能会有重复的序列。为了消除这种重复，应该这样改写代码：

```python
class Solution:
    def combinationSum(self, candidates: 'List[int]', target: int) -> 'List[List[int]]':
        ans = []

        def recursive(i, sum_, seq):
            if i >= len(candidates) or sum_ >= target:
                if sum_ == target:
                    ans.append(seq)
                return
            for j in range(i, len(candidates)):
                recursive(j, sum_+candidates[j], seq+[candidates[j]])

        recursive(0, 0, [])
        return ans
```

这个方法，可以这样理解：由`candidates[0:n]`组成的和为`target`的序列，可以分为`n`种，其中第`i`种为必包含`candidates[i]`，且只包含来自`candidates[i:n]`的元素的序列。因此，要统计出所有第`i`种序列，只需要统计出所有由`candidates[i:n]`组成的和为`target-candidates[i]`的序列，为它们append一个`candidates[i]`即可。要统计后者可以使用递归。



## 48. Rotate Image

> You are given an *n* x *n* 2D matrix representing an image.
>
> Rotate the image by 90 degrees (clockwise).
>
> **Note:**
>
> You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.
>
> **Example 1:**
>
> ```
> Given input matrix = 
> [
>   [1,2,3],
>   [4,5,6],
>   [7,8,9]
> ],
> 
> rotate the input matrix in-place such that it becomes:
> [
>   [7,4,1],
>   [8,5,2],
>   [9,6,3]
> ]
> ```
>
> **Example 2:**
>
> ```
> Given input matrix =
> [
>   [ 5, 1, 9,11],
>   [ 2, 4, 8,10],
>   [13, 3, 6, 7],
>   [15,14,12,16]
> ], 
> 
> rotate the input matrix in-place such that it becomes:
> [
>   [15,13, 2, 5],
>   [14, 3, 4, 1],
>   [12, 6, 8, 9],
>   [16, 7,10,11]
> ]
> ```

这道题更多的是需要多边界的掌控能力……可以看到，顺时钟旋转90度，其实就是对应位置的4个元素换了一下位置（比如，5 11 16 15，或者 1 10 2 14）。它们在位置上是有联系的。具体地说，`matrix[i][j]`会跟`matrix[j][-i - 1], matrix[-i - 1][-j - 1], matrix[-j - 1][i]`这三个元素换位。因此，只要访问左上角的`i, j`，再进行换位，就可以完成旋转。比较难的是确定边界。经过思考和debug，确定`i`的取值范围是`[0, ceil(len(matrix)/2)]`，而`j`的取值范围是`[0, len(matrix[0])//2]`。

```python
from math import ceil
class Solution:
    def rotate(self, matrix: 'List[List[int]]') -> None:
        if not matrix or not matrix[0]:
            return

        for i in range(ceil(len(matrix)/2)):
            for j in range(len(matrix[0]) // 2):
                matrix[i][j], matrix[j][-i - 1], matrix[-i - 1][-j - 1], matrix[-j - 1][i] = matrix[-j - 1][i], matrix[i][j], matrix[j][-i - 1], matrix[-i - 1][-j - 1]
```

[这个人](https://leetcode.com/problems/rotate-image/discuss/18884/Seven-Short-Solutions-(1-to-7-lines))把下标简化了一下，用`~i`代替`-i-1`，也是可以的。这个[答案](https://leetcode.com/problems/rotate-image/discuss/18872/A-common-method-to-rotate-the-image)提出了另外两种顺时钟旋转矩阵的方法。分别是：将矩阵的行上下翻转，再求其转置。



## 215. Kth Largest Element in an Array

> Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
>
> **Example 1:**
>
> ```
> Input: [3,2,1,5,6,4] and k = 2
> Output: 5
> ```
>
> **Example 2:**
>
> ```
> Input: [3,2,3,1,2,4,5,5,6] and k = 4
> Output: 4
> ```

这道题的直觉做法是维护一个大小为`k`的最小堆，将每个元素`push`进堆中，然后`pop`出`n-k`个，保留`k`个。剩下的最小元素就是第`k`大的元素。这种做法固然好，但是有一个更加合适的算法，称为[QuickSelect算法](https://en.wikipedia.org/wiki/Quickselect)。它有点像快排。逆序快排的一种形式是，选择一个`pivot`，然后将所有大于`pivot`的元素移动到数组前面，后面的元素就是小于等于`pivot`的。设共有`x`个元素比`pivot`大，将`pivot`这个元素和`arr[x]`交换，这样`arr[:x]`是比`pivot`大的元素，`arr[x+1:]`的元素不大于`pivot`。对`arr[:x]`和`arr[x+1:]`继续用快排，直到完全排好为止。事实上，如果当前轮的`pivot`被放在`arr[k-1]`位置上，可以看出共有`k-1`个元素比`pivot`大，`n-k+1`个元素不大于`pivot`。那么`pivot`就是第`k`大的元素了。这样在快排的过程中，可以在完全排序好之前知道第`k`大的元素。

另外，快排会递归地排序`arr[:x]`和`arr[x+1:]`两部分。但是，我们的目的是为了找到第`k`大的元素。`arr[:x]`中的元素都比`arr[x]`大。如果`x < k`，显然第`k`大的元素不可能在`arr[:x]`中。所以不必去排序`arr[:x]`了，只用关注`arr[x+1:]`即可。如果`x >= k`，显然第`k`大的元素是在`arr[:x]`之中。所以也不必去排序`arr[x+1:]`。这个过程就像二分查找，每次平均能排除一半的候选项。

不过，即使QuickSelect这个方法在理论上很美妙，但提交给LeetCode，它的性能比堆排序差多了……不明白是为什么。

```c++
// heap
class Solution {
   public:
    int findKthLargest(vector<int> &nums, int k) {
        std::priority_queue<int, std::vector<int>, std::greater<int>> pq;
        for (int num : nums) {
            pq.push(num);
            if (pq.size() > k) pq.pop();
        }
        return pq.top();
    }
};
// quick sort
class Solution {
    int qsort(vector<int> &arr, int l, int r, int k) {
        if (l >= r) return arr[l];
        int pivot = arr[r], p = l, tmp;
        for (int i = l; i <= r; ++i) {
            if (arr[i] > pivot) tmp = arr[i], arr[i] = arr[p], arr[p] = tmp, ++p;
        }
        tmp = arr[p], arr[p] = arr[r], arr[r] = tmp;
        // there is p elements greater than pivot
        if (p == k - 1) {
            return pivot;
        } else if (p < k) {
            // there are less than k elements greater than pivot
            // the answer cannot be among these p elements
            // so do not need to sort arr[:p]
            return qsort(arr, p + 1, r, k);
        } else {
            return qsort(arr, l, p - 1, k);
        }
    }
   public:
    int findKthLargest(vector<int> &nums, int k) {
        return qsort(nums, 0, nums.size()-1, k);
    }
};
```



## 287. Find the Duplicate Number

```c++
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Example 1:

Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
```

假设我们构造一个有`n+1`个节点的图，编号为`0~n`。对数组`arr`的每个元素`arr[i] == x`，我们在图中添加一条有向边，从节点`i`指向节点`x`。由于`arr[1:n+1]`共有`n`个元素，范围在`1~n`之间，所以这`n`个元素为节点`1`到`n`连接了共`n`条边。节点`1`到`n`之间必有环，否则边的数目不超过`n-1`。而节点`0`是无入度的，因为`arr`中没有值为`0`的元素。假设`arr[0] == y`。加上`0->y`这一条边，节点`1`到`n`中必有至少一个节点的入度大于1。假设这个节点的编号是`d`。由于有两条以上的有向边指向它，所以必有超过两个数组元素的值等于`d`，这意味着`d`就是我们要找的重复元素。也就是说，我们找重复元素的任务，等价于在图中找一个入度大于1的节点。

另一方面，从节点`0`出发，每次沿着一条边前进到下一个节点，肯定会走入一个环。这是因为每个节点都有出度（这条出边的目的节点号是节点对应的`arr[i]`的值）。环的入口在节点`1`到`n`之中，且它的入度大于1。这个节点的编号就是重复元素。至此，我们把寻找重复元素的任务，化成了在有环图中寻找环入口节点的任务。

要寻找环的入口，可以用[Floyd's Tortoise and Hare Algorithm](https://en.wikipedia.org/wiki/Cycle_detection)。这个算法是比较常见的，我就不介绍了。

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];  // go to next node
            fast = nums[nums[fast]];    // 2 steps
        } while (slow != fast);     // meet in circle
        // suppose distance from start to entrance of circle is x
        // distance from entrance to meet point is y
        // distance from meet point to entrance is z
        // then, slow goes (x + y) steps
        // fast goes (x + y + z + y) steps (1 whole circle)
        // then: 2 * (x + y) == (x + 2 * y + z) -> x == z
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```



## 102. Binary Tree Level Order Traversal

> Given a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).
>
> For example:
> Given binary tree `[3,9,20,null,null,15,7]`,
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
>
> 
>
> return its level order traversal as:
>
> ```
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
> ```

层次遍历是非常基本的知识。用一个队列来存储当前层的所有节点。设当前层有`x`个节点。在对该层遍历时，从队列中`pop`出`x`个节点，对它们访问后，将它们的非空孩子压入队列中。在遍历完最后一层后，队列会变空。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root) return {};
        queue<TreeNode*> level;
        vector<vector<int>> rtn;
        level.push(root);
        while (!level.empty()) {
            rtn.push_back(vector<int>());
            int level_num = level.size();
            for (int i = 0; i < level_num; ++i) {
                TreeNode *node = level.front(); level.pop();
                rtn.back().push_back(node->val);
                if (node->left) level.push(node->left);
                if (node->right) level.push(node->right);
            }
        }
        return rtn;
    }
};
```



## 21. Merge Two Sorted Lists

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
>
> **Example:**
>
> ```
> Input: 1->2->4, 1->3->4
> Output: 1->1->2->3->4->4
> ```

为了方便，可以设置一个虚拟的头节点。同时遍历`l1 l2`链表，比较它们，将较小的节点接到虚拟头结点开始的链表中。

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode *head = new ListNode(0); // virtual head
        ListNode *curr = head;
        while (l1 && l2) {
            if (l1->val < l2->val) curr->next = l1, l1 = l1->next;
            else curr->next = l2, l2 = l2->next;
            curr = curr->next;
        }
        if (l1) curr->next = l1;
        if (l2) curr->next = l2;
        curr = head->next;
        delete head;
        return curr;
    }
};
```



## 62. Unique Paths

> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).
>
> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
>
> How many possible unique paths are there?
>
> ![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)
> Above is a 7 x 3 grid. How many possible unique paths are there?
>
>  
>
> **Example 1:**
>
> ```
> Input: m = 3, n = 2
> Output: 3
> Explanation:
> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
> 1. Right -> Right -> Down
> 2. Right -> Down -> Right
> 3. Down -> Right -> Right
> ```
>
> **Example 2:**
>
> ```
> Input: m = 7, n = 3
> Output: 28
> ```



非常基础的动态规划问题。用`dp[i][j]`表示到达`grid[i][j]`的路径数，那么

```python
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

```python
def uniquePaths(self, m: int, n: int) -> int:
	dp = [[0 for _ in range(n)] for _ in range(m)]
	for i in range(m):
	    for j in range(n):
	        if i == 0 and j == 0:
	            dp[i][j] = 1
	        else:
	            if i > 0:
	                dp[i][j] += dp[i-1][j]
	            if j > 0:
	                dp[i][j] += dp[i][j-1]
	return dp[-1][-1]
```

因为这个动态规划的累加是有序的，所以至多用一个一维数组就够了，用来记录`dp[i-1][j]`：

```python
def uniquePaths(self, m: int, n: int) -> int:
	dp = [0 for _ in range(n)]
	for i in range(m):
	    for j in range(n):
	        if i == 0 and j == 0:
	            dp[j] = 1
	        else:
	            if i > 0:
	                # dp[i][j] += dp[i-1][j]. do nothing
	                pass
	            if j > 0:
	                dp[j] += dp[j-1]
	return dp[-1]
```

时间复杂度为$O(mn)$。



## 64. Minimum Path Sum

> Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.
>
> **Note:** You can only move either down or right at any point in time.
>
> **Example:**
>
> ```
> Input:
> [
>   [1,3,1],
>   [1,5,1],
>   [4,2,1]
> ]
> Output: 7
> Explanation: Because the path 1→3→1→1→1 minimizes the sum.
> 
> ```

这道题可以用动态规划解决。另`dp[i][j]`表示走到`grid[i][j]`的最小花费。显然有`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。这里向62题一样，用一个一维的`dp`数组就可以了。

```c++
#define min(x, y) ( (x) < (y) ? (x) : (y) )
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if (!grid.size() || !grid[0].size()) return 0;
        // dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        vector<int> dp(grid[0].size(), 0);
        dp[0] = grid[0][0];
        for (int j = 1; j < grid[0].size(); ++j) dp[j] = dp[j-1] + grid[0][j];
        for (int i = 1; i < grid.size(); ++i) {
            dp[0] += grid[i][0];
            for (int j = 1; j < grid[0].size(); ++j)
                dp[j] = min(dp[j-1], dp[j]) + grid[i][j];
        }
        return dp.back();
    }
};
```



## 312. Burst Balloons

> Given `n` balloons, indexed from `0` to `n-1`. Each balloon is painted with a number on it represented by array `nums`. You are asked to burst all the balloons. If the you burst balloon `i` you will get `nums[left] * nums[i] * nums[right]` coins. Here `left` and `right` are adjacent indices of `i`. After the burst, the `left` and `right` then becomes adjacent.
>
> Find the maximum coins you can collect by bursting the balloons wisely.
>
> **Note:**
>
> - You may imagine `nums[-1] = nums[n] = 1`. They are not real therefore you can not burst them.
> - 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100
>
> **Example:**
>
> ```
> Input: [3,1,5,8]
> Output: 167 
> Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
>              coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
> ```

这是一个动态规划问题。为了方便，在数组的首尾各添加一个1，作为所谓的`nums[-1] nums[n]`。令`dp[i][j]`表示子数组`nums[i:j+1]`的气球全部爆炸以后能获得的最大金币数。在所有气球中，如果`nums[p]`是最后爆炸的，那么炸掉它获得的金币数是`nums[p]`，炸掉它左边的所有气球获得的金币数是`dp[0][p]`，炸掉右边的所有气球获得的金币数是`dp[p+1][-1]`。因此，就有`dp[0][-1] == dp[0][p] + dp[p+1][-1] + nums[p]`。尝试所有的`p`，可以求出一个最大的`dp[0][-1]`，便是最终的答案。而求`dp[0][p] dp[p+1][-1]`，可以用类似的思路递归求出。

```c++
class Solution {
    vector<vector<int>> dp;
    int recursive(vector<int> &nums, int i, int j) {
        // calculate dp[i][j]
        if (dp[i][j] != -1) return dp[i][j];    // already calculated
        if (i + 1 == j) return 0;  // no balloons left
        // try p
        int max_coin = -1, curr_coin;
        for (int p = i + 1; p < j; ++p) {
            curr_coin = recursive(nums, i, p) + recursive(nums, p, j) + nums[i] * nums[j] * nums[p];
            if (curr_coin > max_coin) max_coin = curr_coin;
        }
        dp[i][j] = max_coin;
        return max_coin;
    }
public:
    int maxCoins(vector<int>& nums) {
        if (nums.empty()) return 0;
        nums.push_back(1), nums.insert(nums.begin(), 1);
        dp = vector<vector<int>>(nums.size(), vector<int>(nums.size(), -1));
        return recursive(nums, 0, nums.size()-1);
    }
};
```



## 96. Unique Binary Search Trees

> Given *n*, how many structurally unique **BST's** (binary search trees) that store values 1 ... *n*?
>
> **Example:**
>
> ```
> Input: 3
> Output: 5
> Explanation:
> Given n = 3, there are a total of 5 unique BST's:
> 
>    1         3     3      2      1
>     \       /     /      / \      \
>      3     2     1      1   3      2
>     /     /       \                 \
>    2     1         2                 3
> ```

这是一道动态规划题。设`dp[i]`是节点数为`i`的二叉搜索树的数量。节点为`i`的二叉搜索树的根节点可以在`1~i`之间，设它的根节点为`x`，那么`1~x-1`这些节点必定在它的左子树中，`x+1~i`则在右子树上。所以它的左子树有`x-1`个节点，右子树有`i-x`个节点。左子树的形态共有`dp[x-1]`种，右子树的形态共有`dp[i-x]`种。因此，以`x`为根，节点数为`n`的二叉搜索树共有`dp[x-1] * dp[i-x]`种。

```c++
class Solution {
public:
    int numTrees(int n) {
        if (n <= 1) return n;
        vector<int> dp(n+1, 0);
        dp[0] = 1;  // empty tree
        for (int i = 1; i <= n; ++i) {
            for (int x = 1; x <= i; ++x) {
                dp[i] += dp[x-1] * dp[i-x];
            }
        }
        return dp[n];
    }
};
```





## 198. 213. 337. House Robber I & II & III

> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.
>
> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.
>
> **Example 1:**
>
> ```
> Input: [1,2,3,1]
> Output: 4
> Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
>              Total amount you can rob = 1 + 3 = 4.
> ```
>
> **Example 2:**
>
> ```
> Input: [2,7,9,3,1]
> Output: 12
> Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
>              Total amount you can rob = 2 + 9 + 1 = 12.
> ```

第一道题可以用动态规划解决。设`dp[i]`是在`nums[:i+1]`之中抢劫，能抢到的最大金额。对于`nums[i]`，有两种可能，要么抢劫它，那么`dp[i] = dp[i-2] + nums[i]`；要么不抢劫它，那么`dp[i] = dp[i-1]`。这两种可能的最大值即是`dp[i]`的值。可以用两个变量来记录`dp[i-2]`和`dp[i-1]`，那么就不用`dp`向量了。

```c++
#define max(x, y) ( (x) > (y) ? (x) : (y) )
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        for (int i = 1; i < dp.size(); ++i) {
            dp[i] = nums[i];
            if (i > 1) dp[i] += dp[i-2];
            dp[i] = max(dp[i], dp[i-1]);
        }
        return dp.back();
    }
};
```

> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.
>
> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.
>
> **Example 1:**
>
> ```
> Input: [2,3,2]
> Output: 3
> Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
>              because they are adjacent houses.
> ```
>
> **Example 2:**
>
> ```
> Input: [1,2,3,1]
> Output: 4
> Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
>              Total amount you can rob = 1 + 3 = 4.
> ```

和I几乎一样，只是`nums[0]`和`nums[-1]`挨在一起，不能同时被偷。那么，可以分别计算`nums[0:-1]`和`nums[1:]`被偷后的最大金额，再比较它们，取最大值为答案。

```c++
class Solution {
    int _rob(vector<int>& nums, int l, int r) {
        // max rob num of nums[l:r]
        vector<int> dp(r - l, 0);
        dp[0] = nums[l];
        for (int i = 1; i < dp.size(); ++i) {
            dp[i] = nums[i+l];
            if (i > 1) dp[i] += dp[i-2];
            dp[i] = max(dp[i], dp[i-1]);
        }
        return dp.back();
    }
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        if (nums.size() == 1) return nums[0];
        int rob1 = _rob(nums, 0, nums.size()-1), rob2= _rob(nums, 1, nums.size());
        return max(rob1, rob2);
    }
};

```

> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.
>
> Determine the maximum amount of money the thief can rob tonight without alerting the police.
>
> **Example 1:**
>
> ```
> Input: [3,2,3,null,3,null,1]
> 
>      3
>     / \
>    2   3
>     \   \ 
>      3   1
> 
> Output: 7 
> Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
> ```
>
> **Example 2:**
>
> ```
> Input: [3,4,5,1,3,null,1]
> 
>      3
>     / \
>    4   5
>   / \   \ 
>  1   3   1
> 
> Output: 9
> Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
> ```

这次房子不是线性排列的，而是呈二叉树形状排列的。不能同时偷相邻的两个房子，即是不能同时偷一个父节点和它的孩子。思路和前面两个基本一样。令`dp[node]`为以节点`node`为根的子树所能抢到的最大金额。对于一个节点`node`，要么抢它，获得最多`node->val + dp[node->left->left] + dp[node->left->right] + dp[node->right->left] + dp[node->right->right]`这么多钱（`node`的两个孩子不能抢，只能跨代抢）；要么不抢，获得最多`dp[node->left] + dp[node->right]`这么多钱。这两个数值相比较，取较大的作为`dp[node]`。

```c++
class Solution {
    std::map<TreeNode*, int> dp;
    int get_dp(TreeNode *node) {
        if (dp.find(node) != dp.end()) return dp[node];
        int not_rob = 0;
        if (node->left) not_rob += get_dp(node->left);
        if (node->right) not_rob += get_dp(node->right);
        int rob = node->val;
        if (node->left) {
            if (node->left->left) rob += get_dp(node->left->left);
            if (node->left->right) rob += get_dp(node->left->right);
        }
        if (node->right) {
            if (node->right->left) rob += get_dp(node->right->left);
            if (node->right->right) rob += get_dp(node->right->right);
        }
        dp[node] = max(not_rob, rob);
        return dp[node];
    }
public:
    int rob(TreeNode* root) {
        if (!root) return 0;
        return get_dp(root);
    }
};
```





## 121.122.123.188.309.714 Best Time to Buy and Sell Stock I & II & III & IV & Cooldown & Transaction Fee

> Say you have an array for which the *i*th element is the price of a given stock on day *i*.
>
> If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
>
> Note that you cannot sell a stock before you buy one.
>
> **Example 1:**
>
> ```
> Input: [7,1,5,3,6,4]
> Output: 5
> Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
>              Not 7-1 = 6, as selling price needs to be larger than buying price.
> ```
>
> **Example 2:**
>
> ```
> Input: [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.
> ```

遍历每一天的股票价格，在当天能够获得的最大收益，是当天价格减去过去最低的价格。所以用一个变量来记住过去最低的价格，比较今天是否可以卖出比以往更高的收益即可。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price = 0x7fffffff, max_profit = 0;
        for (int price: prices) {
            if (price - min_price > max_profit) max_profit = price - min_price;
            if (price < min_price) min_price = price;
        }
        return max_profit;
    }
};
```

> You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
>
> **Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).
>
> **Example 1:**
>
> ```
> Input: [7,1,5,3,6,4]
> Output: 7
> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
>              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
> ```
>
> **Example 2:**
>
> ```
> Input: [1,2,3,4,5]
> Output: 4
> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
>              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
> ```
>
> **Example 3:**
>
> ```
> Input: [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.
> ```

如果第`i+1`天的股价比第`i`天高，且手中有股票，那么肯定不会在第`i`天卖，而是等到第`i+1`天卖。同样的，如果第`i+1`天股价比第`i`天低，那肯定不会留到第`i+1`天才卖。可以给股价变化画一个曲线图。在股价上升时我们持有股票；在股价下降时空仓，这样每次股价的上升我们都能赚到，每次股价下跌我们都能避免损失。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        int profit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i] > prices[i-1])
                profit += prices[i] - prices[i-1];
        }
        return profit;
    }
};
```

> You may complete at most *two* (*k*) transactions.
>
> **Example 1:**
>
> ```
> Input: [3,3,5,0,0,3,1,4]
> Output: 6
> Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
>              Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
> ```
>
> **Example 2:**
>
> ```
> Input: [1,2,3,4,5]
> Output: 4
> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
>              Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
>              engaging multiple transactions at the same time. You must sell before buying again.
> ```
>
> **Example 3:**
>
> ```
> Input: [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.
> ```

III和IV是类似的。III规定最多可以买卖2次，IV规定最多可以买卖`k`次。可以用动态规划来解决这个问题。令`dp[k][i]`为在第`1~i`天中，进行至多`k`次交易能获得的最大收益。易知`dp`的转移公式是`dp[k][i] = max(dp[k][i-1], prices[i-1]-prices[j-1]+dp[k-1][j-1])`。第一项，`dp[k][i-1]`，表示第`i`天不交易，所以能获得的最大收益和前一天的一样；`prices[i-1]-prices[j-1]+dp[k-1][j-1]`表示今天卖出第`j`天买入的股票。由于对每个`i`，需要对`1~i-1`之间的所有`j`求`prices[i-1]-prices[j-1]+dp[k-1][j-1]`，然后计算最大值，会导致时间复杂度高达`O(kn^2)`，提交超时。通过观察，可以发现，求`prices[i-1]-prices[j-1]+dp[k-1][j-1]`大部分是冗余的。可以在`i`的迭代中记录`max_j(prices[i-1]-prices[j-1]+dp[k-1][j-1])`，以省去内层循环。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        // dp[k][i] = max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1])
        vector<vector<int>> dp(3, vector<int>(prices.size()+1, 0));
        for (int k = 1; k <= 2; ++k) {
            for (int i = 2; i <= prices.size(); ++i) {
                int max_profit = dp[k][i-1], curr_profit;
                for (int j = 1; j < i; ++j) {
                    curr_profit = prices[i-1] - prices[j-1] + dp[k-1][j-1];
                    if (curr_profit > max_profit) max_profit = curr_profit;
                }
                dp[k][i] = max_profit;
            }
        }
        return dp[2][prices.size()];
    }
};
// 上面的答案时间复杂度为O(kn^2)，超时了。按照原文的建议，删改了最内层循环
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() <= 1) return 0;
        // dp[k][i] = max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1])
        vector<vector<int>> dp(3, vector<int>(prices.size(), 0));
        for (int k = 1; k <= 2; ++k) {
            int min_price = prices[0], curr_price, curr_profit;
            for (int i = 1; i < prices.size(); ++i) {
                curr_price = prices[i] - dp[k-1][i-1];
                if (min_price > curr_price) min_price = curr_price;
                curr_profit = prices[i] - min_price;
                dp[k][i] = curr_profit > dp[k][i-1] ? curr_profit : dp[k][i-1];
            }
        }
        return dp[2][prices.size()-1];
    }
};
```

> You may complete at most **k** transactions.
>
> **Note:**
> You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
>
> **Example 1:**
>
> ```
> Input: [2,4,1], k = 2
> Output: 2
> Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
> ```
>
> **Example 2:**
>
> ```
> Input: [3,2,6,5,0,3], k = 2
> Output: 7
> Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
>              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
> ```















