---
layout: post
title: 剑指offer-树
excerpt: "剑指offer问题的解答：树"
categories: [Algorithm]
comments: true
---

## 04-重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

[LeetCode相似问题](<https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>)

前序遍历一棵树，首先访问的是它的根节点，然后是左子树上的节点，然后是右子树上的节点。而中序遍历一棵树，首先访问它左子树上的节点，其次是根节点，然后是右子树上的节点。因此，给定了前序遍历`pre`和中序遍历`tin`的结果，就可以确定，根节点是`pre[0]`。在`tin`中找出根节点的位置，它左边的节点就是左子树上的，右边的节点是右子树上的。通过计算这些节点的数目，就可以在`pre`上也划分出左右子树节点的范围。使用递归，构造左右子树。

LeetCode上的对应问题也是类似的。后序遍历中，根节点是最后一个访问的，因此也可以直接找出根节点。然后再根据中序遍历结果找出左右子树节点的范围，结合后序遍历结果，同样使用递归来构造左右子树即可。

```python
def reConstructBinaryTree(self, pre, tin):
	if not pre:
	    return None
	root = TreeNode(pre[0])
	root_idx = tin.index(pre[0])
	root.left = self.reConstructBinaryTree(pre[1:1+root_idx],
	                                       tin[:root_idx])
	root.right = self.reConstructBinaryTree(pre[1+root_idx:],
	                                        tin[root_idx+1:])
	return root
```



---



## 17-树的子结构

> 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

子树和子结构不太一样。B是A的子树，表示A的某个子树A'和B完全一样（包括节点数、节点关系）。而B是A的子结构，表示A的某个子树A'，通过删减去一些节点，可以得到B。判断子结构的做法跟判断子树的其实差不多，只需要做一些修改。

判断子树的相似问题来自于[LeetCode](<https://leetcode.com/problems/subtree-of-another-tree/>).

`HasSubStructure`可设计成一个递归函数，如果树B是树A的子结构，则返回`True`;否则返回`False`。在递归过程中：

1. 如果A、B都不为空树，且A的根节点和B的根节点值不一样时，如果B是A的子结构，那就只能是A的左子树或者右子树的子结构。返回`HasSubStructure(A.left, B) or HasSubStructure(A.right, B)`.
2. 如果A、B都不为空树，且A的根节点和B的根节点值一样时，会有两种可能：1）B是A左右子树的子结构；2）B的左子树是A左子树的子结构，而B的右子树是A右子树的子结构。即是说，将A变成B所要删减去的点，不包括A的根节点。1）和2）都是有可能的，只有在递归尝试了`HasSubStructure(A.left, B)`，`HasSubStructure(A.right, B)`和`HasSubStructure(A.left, B.left) and HasSubStructure(A.right, B.right)`，并且都返回`False`之后，才能说明B不是A的子结构。
3. 如果B是空树，按定义B不是A的子结构，因为空树不是任意树的子结构。但是在递归过程中，B很有可能不是原来的B，而只是它的一棵子树。这种情况下，函数是应该返回`True`的，因为它说明A的某一个部分，“包含”了B的一个子树。接下来的任务，就是判断B的其他子树有没有被A包含。可以给`HasSubStructure`加一个带有缺省值的参数，来标识B是否是一个子树。
4. 如果A是空树，但B不是空树，函数`HasSubStructure`则毫无疑问返回`False`。这是因为非空树B不可能是空树的子结构。

根据以上分析，代码看起来会是这样子：

```python
class Solution:
    def HasSubStructure(self, A, B, child=False):
        if not B:
            return child
        elif not A:
            return False
        elif A.val == B.val:
            return (self.HasSubStructure(A.left, B.left, True) and self.HasSubStructure(A.right, B.right, True)) \
                    or self.HasSubStructure(A.left, B, child) or self.HasSubStructure(A.right, B, child)
        else:
            return self.HasSubStructure(A.left, B, child) or self.HasSubStructure(A.right, B, child)
        
```

除了单行太长以外，看上去挺简洁的……

判断B是否A的子树道理本质上相同。注意空树**是**任意树的子树（跟子结构的定义相反）。在判断子树时，逻辑需要修改一下：

1. 如果A、B都不为空树，且A的根节点和B的根节点值不一样时，如果B是A的子树，那就只能是A的左子树或者右子树的子树。返回`isSubtree(A.left, B) or isSubtree(A.right, B)`.
2. 如果A、B都不为空树，且A的根节点和B的根节点值一样时，会有两种可能：1）B是A左右子树的子树；2）A和B相同。1）和2）都是有可能的，首先要比较A和B是否相同。使用另一个函数`compare`来作比较。如果不同，再递归地尝试`isSubtree(A.left, B)`，`isSubtree(A.right, B)`。
3. 如果B是空树，那么按照定义，B应该是A的子树。函数`isSubtree`直接返回`True`。
4. 如果A是空树，但B不是空树，函数`isSubtree`则直接返回`False`。这是因为非空树B不可能是空树的子树。

综上，判断子树的代码如下：

```python
class Solution:
    def compare(self, A, B):
        if not A and not B:
            return True
        if not A or not B or A.val != B.val:
            return False
        return self.compare(A.left, B.left) and self.compare(A.right, B.right)

    def isSubtree(self, A, B):
        if not B:
            return True
        if not A:
            return False
        if A.val != B.val:
            return self.isSubtree(A.left, B) or self.isSubtree(A.right, B)
        else:
            return self.compare(A, B) or self.isSubtree(A.left, B) or self.isSubtree(A.right, B)
```

这道题快速地一次做对的关键，就是要先分析在递归过程中，如何进行逻辑判断。这是在写复杂代码前至关重要的一个步骤。没有经过思考就下笔，代码可能会藏有诸多漏洞，而且冗长丑陋。所以，在下次做题之前，一定要先对问题进行分析，尤其是要搞明白边界的细节问题之后，方可开始书写代码。



